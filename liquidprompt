################################################################################
# LIQUID PROMPT
# An intelligent and non-intrusive prompt for Bash and zsh
################################################################################

# Licensed under the AGPL version 3
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Issue #161: do not load if not an interactive shell
test -z "$TERM" -o "x$TERM" = xdumb && return

if test -n "${BASH_VERSION-}"; then
    _LP_SHELL_bash=true
    _LP_SHELL_zsh=false
    _LP_OPEN_ESC="\["
    _LP_CLOSE_ESC="\]"

    _LP_USER_SYMBOL="\u"
    _LP_HOST_SYMBOL="\h"
    _LP_FQDN_SYMBOL="\H"
    _LP_TIME_SYMBOL="\t"
    _LP_MARK_SYMBOL='\$'
    _LP_PWD_SYMBOL="\\w"
    _LP_DIR_SYMBOL="\\W"

    _LP_PERCENT='%'    # must be escaped on zsh
    _LP_BACKSLASH='\\' # must be escaped on bash

    # Sed expression using extended regexp to match terminal
    # escape sequences with their wrappers
    _LP_CLEAN_ESC='\\\[([^\]+|\\[^]])*\\\]'

    # Escape the given strings
    # Must be used for all strings injected in PS1 that may comes from remote sources,
    # like $PWD, VCS branch names...
    __lp_escape() {
        ret="${1//\\/\\\\}"
    }
elif test -n "${ZSH_VERSION-}"; then
    _LP_SHELL_bash=false
    _LP_SHELL_zsh=true
    _LP_OPEN_ESC="%{"
    _LP_CLOSE_ESC="%}"

    _LP_USER_SYMBOL="%n"
    _LP_HOST_SYMBOL="%m"
    _LP_FQDN_SYMBOL="%M"
    _LP_TIME_SYMBOL="%*"
    _LP_MARK_SYMBOL='%(!.#.%%)'
    _LP_PWD_SYMBOL="%~"
    _LP_DIR_SYMBOL="%1~"

    _LP_PERCENT='%%'
    _LP_BACKSLASH="\\"

    _LP_CLEAN_ESC='%\{([^%]+|%[^}])*%\}'

    __lp_escape() {
        local arg="${1//\\/\\\\}"
        ret="${arg//\%/$_LP_PERCENT}"
    }
else
    echo "liquidprompt: shell not supported" >&2
    return
fi

#################
# CONFIGURATION #
#################

# The following code is run just once. But it is encapsulated in a function
# to benefit of 'local' variables.
#
# What we do here:
# 1. Setup variables that can be used by the user: the "API" of Liquid Prompt
#    for config/theme. Those variables are local to the function.
#    In practice, this is only color variables.
# 2. Setup default values
# 3. Load the configuration
_lp_source_config() {
    # TermInfo feature detection
    typeset -a af_colors ab_colors
    local af_color ab_color

    # TODO handle this case better. With no colors, no need for any escaping
    if ! command -v tput >/dev/null; then
        echo "liquidprompt: 'tput' not available; will not be able to format terminal" >&2
    fi

    local ti_sgr0="$( { tput sgr0 || tput me ; } 2>/dev/null )"
    local ti_bold="$( { tput bold || tput md ; } 2>/dev/null )"
    if tput setaf 0 >/dev/null 2>&1; then
        foreground_color() { af_color="${af_colors[$1+1]:=$(tput setaf $1)}"; }
    elif tput AF 0 >/dev/null 2>&1; then
        # FreeBSD
        foreground_color() { af_color="${af_colors[$1+1]:=$(tput AF $1)}"; }
    elif tput AF 0 0 0 >/dev/null 2>&1; then
        # OpenBSD
        foreground_color() { af_color="${af_colors[$1+1]:=$(tput AF $1 0 0)}"; }
    else
        echo "liquidprompt: terminal $TERM does not support foreground colors" >&2
        foreground_color() { : ; }
    fi
    if tput setab 0 >/dev/null 2>&1; then
        background_color() { ab_color="${ab_colors[$1+1]:=$(tput setab $1)}"; }
    elif tput AB 0 >/dev/null 2>&1; then
        # FreeBSD
        background_color() { ab_color="${ab_colors[$1+1]:=$(tput AB $1)}"; }
    elif tput AB 0 0 0 >/dev/null 2>&1; then
        # OpenBSD
        background_color() { ab_color="${ab_colors[$1+1]:=$(tput AB $1 0 0)}"; }
    else
        echo "liquidprompt: terminal $TERM does not support background colors" >&2
        background_color() { : ; }
    fi

    # Colors: variables are local so they will have a value only
    # during config loading and will not conflict with other values
    # with the same names defined by the user outside the config.
    local BOLD="${_LP_OPEN_ESC}${ti_bold}${_LP_CLOSE_ESC}"

    # Foreground colors
    foreground_color 0
    local BLACK="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GRAY="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 1
    local RED="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_RED="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"
    foreground_color 0
    background_color 1
    local WARN_RED="${_LP_OPEN_ESC}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    foreground_color 7
    local CRIT_RED="${_LP_OPEN_ESC}${ti_bold}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    foreground_color 3
    local DANGER_RED="${_LP_OPEN_ESC}${ti_bold}${af_color}${ab_color}${_LP_CLOSE_ESC}"

    foreground_color 2
    local GREEN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GREEN="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 3
    local YELLOW="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_YELLOW="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 4
    local BLUE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_BLUE="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 5
    local PURPLE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local MAGENTA="${PURPLE}"
    local PINK="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_PURPLE="${PINK}"
    local BOLD_MAGENTA="${PINK}"

    foreground_color 6
    local CYAN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_CYAN="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 7
    local WHITE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_WHITE="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    # NO_COL is special: it will be used at runtime, not just during config loading
    NO_COL="${_LP_OPEN_ESC}${ti_sgr0}${_LP_CLOSE_ESC}"

    unset -f foreground_color background_color

    local configfile

    # System config
    configfile="/etc/xdg/liquidprompt/liquidpromptrc"
    [[ -f "$configfile" ]] && source "$configfile"

    # Local config
    configfile="${XDG_CONFIG_HOME:-"$HOME/.config"}/liquidprompt/liquidpromptrc"
    [[ -f "$configfile" ]] && source "$configfile"

    # Default values (globals)
    LP_PATH_LENGTH=${LP_PATH_LENGTH:-35}
    LP_PATH_KEEP=${LP_PATH_KEEP:-2}
    LP_HOSTNAME_ALWAYS=${LP_HOSTNAME_ALWAYS:-0}
    LP_USER_ALWAYS=${LP_USER_ALWAYS:-1}
    LP_PS1=${LP_PS1-""}
    LP_TAG=${LP_TAG-""}

    LP_ENABLE_PERM=${LP_ENABLE_PERM:-1}
    LP_ENABLE_SHORTEN_PATH=${LP_ENABLE_SHORTEN_PATH:-1}
    LP_ENABLE_PROXY=${LP_ENABLE_PROXY:-1}
    LP_ENABLE_JOBS=${LP_ENABLE_JOBS:-0}
    LP_ENABLE_GIT=${LP_ENABLE_GIT:-1}
    LP_ENABLE_OHMYGIT=${LP_ENABLE_OHMYGIT:-0}
    LP_ENABLE_HG=${LP_ENABLE_HG:-1}
    LP_ENABLE_TIME=${LP_ENABLE_TIME:-0}
    LP_ENABLE_VIRTUALENV=${LP_ENABLE_VIRTUALENV:-1}
    LP_ENABLE_SCLS=${LP_ENABLE_SCLS:-1}
    LP_ENABLE_VCS_ROOT=${LP_ENABLE_VCS_ROOT:-0}
    LP_ENABLE_TITLE=${LP_ENABLE_TITLE:-0}
    LP_ENABLE_SCREEN_TITLE=${LP_ENABLE_SCREEN_TITLE:-0}
    LP_ENABLE_FQDN=${LP_ENABLE_FQDN:-0}
    LP_ENABLE_SUDO=${LP_ENABLE_SUDO:-0}
    LP_ENABLE_ERR=${LP_ENABLE_ERR:-0}
    LP_DISABLED_VCS_PATHS=("${LP_DISABLED_VCS_PATHS[@]-}")

    LP_MARK_DEFAULT="${LP_MARK_DEFAULT:-$_LP_MARK_SYMBOL}"
    LP_MARK_PROXY="${LP_MARK_PROXY:-"↥"}"
    LP_MARK_HG="${LP_MARK_HG:-"☿"}"
    LP_MARK_SVN="${LP_MARK_SVN:-"‡"}"
    LP_MARK_GIT="${LP_MARK_GIT:-"±"}"
    LP_MARK_VCSH="${LP_MARK_VCSH:-"|"}"
    LP_MARK_DISABLED="${LP_MARK_DISABLED:-"⌀"}"
    LP_MARK_UNTRACKED="${LP_MARK_UNTRACKED:-"*"}"
    LP_MARK_STASH="${LP_MARK_STASH:-"+"}"
    LP_MARK_BRACKET_OPEN="${LP_MARK_BRACKET_OPEN:-"["}"
    LP_MARK_BRACKET_CLOSE="${LP_MARK_BRACKET_CLOSE:-"]"}"
    LP_MARK_SHORTEN_PATH="${LP_MARK_SHORTEN_PATH:-" … "}"
    LP_MARK_PERM="${LP_MARK_PERM:-":"}"
    LP_MARK_PREFIX="${LP_MARK_PREFIX-" "}"
    LP_MARK_SPACE="${LP_MARK_SPACE:-" "}"
    LP_MARK_VCS_OPEN="${LP_MARK_VCS_OPEN:-"("}"
    LP_MARK_VCS_CLOSE="${LP_MARK_VCS_CLOSE:-")"}"
    LP_MARK_X11="${LP_MARK_X11:-"@"}"

    LP_COLOR_PATH=${LP_COLOR_PATH:-$BOLD}
    LP_COLOR_PATH_ROOT=${LP_COLOR_PATH_ROOT:-$BOLD_YELLOW}
    LP_COLOR_PROXY=${LP_COLOR_PROXY:-$BOLD_BLUE}
    LP_COLOR_JOB_D=${LP_COLOR_JOB_D:-$YELLOW}
    LP_COLOR_JOB_R=${LP_COLOR_JOB_R:-$BOLD_YELLOW}
    LP_COLOR_JOB_Z=${LP_COLOR_JOB_Z:-$BOLD_YELLOW}
    LP_COLOR_ERR=${LP_COLOR_ERR:-$PURPLE}
    LP_COLOR_MARK=${LP_COLOR_MARK:-$BOLD}
    LP_COLOR_MARK_ROOT=${LP_COLOR_MARK_ROOT:-$BOLD_RED}
    LP_COLOR_MARK_SUDO=${LP_COLOR_MARK_SUDO:-$LP_COLOR_MARK_ROOT}
    LP_COLOR_USER_LOGGED=${LP_COLOR_USER_LOGGED:-""}
    LP_COLOR_USER_ALT=${LP_COLOR_USER_ALT:-$BOLD}
    LP_COLOR_USER_ROOT=${LP_COLOR_USER_ROOT:-$BOLD_YELLOW}
    LP_COLOR_HOST=${LP_COLOR_HOST:-""}
    LP_COLOR_SSH=${LP_COLOR_SSH:-$BLUE}
    LP_COLOR_SU=${LP_COLOR_SU:-$BOLD_YELLOW}
    LP_COLOR_TELNET=${LP_COLOR_TELNET:-$WARN_RED}
    LP_COLOR_X11_ON=${LP_COLOR_X11_ON:-$GREEN}
    LP_COLOR_X11_OFF=${LP_COLOR_X11_OFF:-$YELLOW}
    LP_COLOR_WRITE=${LP_COLOR_WRITE:-$GREEN}
    LP_COLOR_NOWRITE=${LP_COLOR_NOWRITE:-$RED}
    LP_COLOR_UP=${LP_COLOR_UP:-$GREEN}
    LP_COLOR_COMMITS=${LP_COLOR_COMMITS:-$YELLOW}
    LP_COLOR_COMMITS_BEHIND=${LP_COLOR_COMMITS_BEHIND:-$BOLD_RED}
    LP_COLOR_CHANGES=${LP_COLOR_CHANGES:-$RED}
    LP_COLOR_DIFF=${LP_COLOR_DIFF:-$PURPLE}
    LP_COLOR_TIME=${LP_COLOR_TIME:-$BLUE}
    LP_COLOR_IN_MULTIPLEXER=${LP_COLOR_IN_MULTIPLEXER:-$BOLD_BLUE}
    LP_COLOR_IN_LOCAL=${LP_COLOR_IN_LOCAL:-$WHITE}
    LP_COLOR_VIRTUALENV=${LP_COLOR_VIRTUALENV:-$CYAN}
}

lp_activate() {
    if $_LP_SHELL_zsh; then
        # For ZSH, autoload required functions
        autoload -Uz add-zsh-hook

        # Disable previous hooks as options that set them
        # may have changed
        {
            add-zsh-hook -d precmd  _lp_set_prompt
        } >/dev/null
    fi

    _lp_source_config

    # Disable feature if the tool is not installed
    _lp_require_tool()
    {
        (( LP_ENABLE_$1 )) && { command -v $2 >/dev/null || eval LP_ENABLE_$1=0 ; }
    }

    _lp_require_tool GIT git
    _lp_require_tool HG hg

    _LP_ENABLED_VCSS=()
    (( LP_ENABLE_GIT )) && _LP_ENABLED_VCSS+=(git)
    (( LP_ENABLE_HG )) && _LP_ENABLED_VCSS+=(hg)

    unset -f _lp_require_tool

    command -v screen >/dev/null ; _LP_ENABLE_SCREEN=$(( ! $? ))
    command -v tmux >/dev/null   ; _LP_ENABLE_TMUX=$(( ! $? ))

    # Use standard path symbols inside Midnight Commander
    [[ -n "${MC_SID-}" ]] && LP_ENABLE_SHORTEN_PATH=0

    # If we are running in a terminal multiplexer, brackets are colored
    if [[ "$TERM" == screen* || -n ${TMUX-} ]]; then
        LP_BRACKET_OPEN="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_OPEN}${NO_COL}"
        LP_BRACKET_CLOSE="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
        (( LP_ENABLE_TITLE = LP_ENABLE_TITLE && LP_ENABLE_SCREEN_TITLE ))
        LP_TITLE_OPEN="$(printf '\033k')"
        # "\e\" but on bash \ must be escaped
        LP_TITLE_CLOSE="$(printf '\033%s' "$_LP_BACKSLASH")"
    else
        LP_BRACKET_OPEN="${LP_COLOR_IN_LOCAL}${LP_MARK_BRACKET_OPEN}${NO_COL}"
        LP_BRACKET_CLOSE="${LP_COLOR_IN_LOCAL}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
        LP_TITLE_OPEN="$(printf '\e]0;')"
        LP_TITLE_CLOSE="$(printf '\a')"
    fi

    ###############
    # Who are we? #
    ###############
    command -v _lp_sudo_check >/dev/null && unset -f _lp_sudo_check

    # Yellow for root, bold if the user is not the login one, else no color.
    if (( EUID != 0 )); then  # if user is not root
        # if user is not login user
        if [[ "${USER}" != "$(logname 2>/dev/null || echo "$LOGNAME")" ]]; then
            LP_USER="${LP_COLOR_USER_ALT}${_LP_USER_SYMBOL}${NO_COL}"
        elif (( LP_USER_ALWAYS )); then
            LP_USER="${LP_COLOR_USER_LOGGED}${_LP_USER_SYMBOL}${NO_COL}"
        else
            LP_USER=""
        fi
        if (( LP_ENABLE_SUDO )) && command -v sudo >/dev/null; then
            LP_COLOR_MARK_NO_SUDO="$LP_COLOR_MARK"
            # Test the code with the commands:
            #   sudo id   # sudo, enter your credentials
            #   sudo -K   # revoke your credentials
            _lp_sudo_check()
            {
                if sudo -n true 2>/dev/null; then
                    LP_COLOR_MARK=$LP_COLOR_MARK_SUDO
                else
                    LP_COLOR_MARK=$LP_COLOR_MARK_NO_SUDO
                fi
            }
        fi
    else # root!
        LP_USER="${LP_COLOR_USER_ROOT}${_LP_USER_SYMBOL}${NO_COL}"
        LP_COLOR_MARK="${LP_COLOR_MARK_ROOT}"
        LP_COLOR_PATH="${LP_COLOR_PATH_ROOT}"
        # Disable VCS info for all paths
        if (( ! LP_ENABLE_VCS_ROOT )); then
            LP_DISABLED_VCS_PATHS=("/")
            LP_MARK_DISABLED="$LP_MARK_DEFAULT"
        fi
    fi

    # Empty _lp_sudo_check if root or sudo disabled
    if ! command -v _lp_sudo_check >/dev/null; then
        _lp_sudo_check() { : ; }
    fi

    #################
    # Where are we? #
    #################

    _lp_hostname

    if (( LP_ENABLE_SHORTEN_PATH )); then
        if (( LP_PATH_KEEP == -1 )); then
            # _lp_shorten_path becomes a noop
            _lp_shorten_path() { : ; }
            # Will never change
            LP_PWD="${LP_COLOR_PATH}${_LP_DIR_SYMBOL}$NO_COL"
        fi
    else
        # Will never change
        LP_PWD="${LP_COLOR_PATH}${_LP_PWD_SYMBOL}$NO_COL"

        if $_LP_SHELL_bash && [[ -n "$PROMPT_DIRTRIM" ]]; then
            unset -f _lp_shorten_path
            alias _lp_shorten_path=_lp_set_dirtrim
        fi
    fi

    _lp_theme_activate
}

#####################
# Utility Functions #
#####################

# Remove all colors and escape characters of the given string and return a pure text
_lp_as_text() {
    # Remove all terminal sequences that we wrapped with $_LP_OPEN_ESC and
    # $_LP_CLOSE_ESC.
    echo -nE "$1" | sed -r "s,$_LP_CLEAN_ESC,,g"
}

# Store $2 (or $?) as a true/false value in variable named $1
# $? is propagated
#   _lp_bool foo 5
#   => foo=false
#   _lp_bool foo 0
#   => foo=true
_lp_bool() {
    local res=${2:-$?}
    if (( res )); then
        eval $1=false
    else
        eval $1=true
    fi
    return $res
}

# Count the number of lines in the input string. A faster subsitute for 'wc -l'.
# input: $1; a single string of input.
# return: $count; the number of newline characters in the string.
__lp_line_count() {
  local var="${1//[!$'\n']}"
  count=${#var}
}

__lp_pwd_tilde() {
    # Needs to be in a variable, as different versions of Bash treat '~' in a
    # substitution differently
    local tilde="~"
    lp_pwd_tilde="${PWD/#$HOME/$tilde}"
}

# insert a space on the right
_lp_sr() {
    [[ -n "$1" ]] && echo -nE "$1${LP_MARK_SPACE}"
}

# insert a space on the left
_lp_sl() {
    [[ -n "$1" ]] && echo -nE "${LP_MARK_SPACE}$1"
}

# insert two space, before and after
_lp_sb() {
    [[ -n "$1" ]] && echo -nE "${LP_MARK_SPACE}$1${LP_MARK_SPACE}"
}

##########################
# Working Directory Path #
##########################

# Shorten the path of the current working directory
# * Show only the current directory
# * Show as much of the cwd path as possible, if shortened display a
#   leading mark, such as ellipses, to indicate that part is missing
# * show at least LP_PATH_KEEP leading dirs and current directory
_lp_shorten_path() {
    if (( ! LP_ENABLE_SHORTEN_PATH )); then
        # We are not supposed to come here often as this case is already
        # optimized at install time
        LP_PWD="${LP_COLOR_PATH}${_LP_PWD_SYMBOL}$NO_COL"
        return
    fi

    local ret=

    local lp_pwd_tilde p
    __lp_pwd_tilde
    p="$lp_pwd_tilde"

    local mask="${LP_MARK_SHORTEN_PATH}"
    local -i max_len=$(( ${COLUMNS:-80} * LP_PATH_LENGTH / 100 ))

    if (( LP_PATH_KEEP == -1 )); then
        # only show the current directory, excluding any parent dirs
        ret="${p##*/}" # discard everything up to and including the last slash
        [[ "${ret}" == "" ]] && ret="/" # if in root directory
    elif (( ${#p} <= max_len )); then
        ret="${p}"
    elif (( LP_PATH_KEEP == 0 )); then
        # len is over max len, show as much of the tail as is allowed
        ret="${p##*/}" # show at least complete current directory
        p="${p:0:${#p} - ${#ret}}"
        ret="${mask}${p:${#p} - (${max_len} - ${#ret} - ${#mask})}${ret}"
    else
        # len is over max len, show at least LP_PATH_KEEP leading dirs and
        # current directory
        local tmp="${p//\//}"
        local -i delims=$(( ${#p} - ${#tmp} ))

        for (( dir=0; dir < LP_PATH_KEEP; dir++ )); do
            (( dir == delims )) && break

            local left="${p#*/}"
            local name="${p:0:${#p} - ${#left}}"
            p="${left}"
            ret+="${name%/}/"
        done

        if (( delims <= LP_PATH_KEEP )); then
            # no dirs between LP_PATH_KEEP leading dirs and current dir
            ret+="${p##*/}"
        else
            local base="${p##*/}"

            p="${p:0:${#p} - ${#base}}"

            [[ ${ret} != "/" ]] && ret="${ret%/}" # strip trailing slash

            local -i len_left=$(( max_len - ${#ret} - ${#base} - ${#mask} ))

            ret+="${mask}${p:${#p} - ${len_left}}${base}"
        fi
    fi
    # Escape special chars
    __lp_escape "$ret"
    LP_PWD="${LP_COLOR_PATH}${ret}$NO_COL"
}

# In Bash shells, PROMPT_DIRTRIM is the number of directories to keep at the end
# of the displayed path (if "\w" is present in the PS1 var).
# Liquid Prompt can calculate this number under two conditions, path shortening
# must be disabled and PROMPT_DIRTRIM must be already set.
_lp_set_dirtrim() {
    local lp_pwd_tilde p
    __lp_pwd_tilde
    p="$lp_pwd_tilde"

    local -i max_len="${COLUMNS:-80}*$LP_PATH_LENGTH/100"
    local -i dt=0

    if (( ${#p} > max_len )); then
        local q="/${p##*/}"
        local show="$q"
        # +3 because of the ellipsis: "..."
        while (( ${#show}+3 < max_len )); do
            (( dt++ ))
            p="${p%$q}"
            q="/${p##*/}"
            show="$q$show"
        done
        (( dt == 0 )) && dt=1
    fi
    PROMPT_DIRTRIM=$dt
    # For debugging
    # echo PROMPT_DIRTRIM=$PROMPT_DIRTRIM >&2
}

###############
# Environment #
###############

_lp_connection() {
    if [[ -n "${SSH_CLIENT-}${SSH2_CLIENT-}${SSH_TTY-}" ]]; then
        echo ssh
    else
        # tmux: see GH #304
        # TODO check on *BSD
        local whoami="$(LC_ALL=C who am i)"
        local sess_parent="$(ps -o comm= -p $PPID 2> /dev/null)"
        if [[ x"$whoami" != *'('* || x"$whoami" = *'(:'* || x"$whoami" = *'(tmux'* ]]; then
            echo lcl  # Local
        elif [[ "$sess_parent" = "su" || "$sess_parent" = "sudo" ]]; then
            echo su   # Remote su/sudo
        else
            echo tel  # Telnet
        fi
    fi
}

_lp_hostname() {
    # Put the hostname if not locally connected
    # color it in cyan within SSH, and a warning red if within telnet
    # else display the host without color
    # The connection is not expected to change from inside the shell, so we
    # build this just once
    LP_HOST=""

    # Only process hostname elements if we haven't turned them off
    if (( LP_HOSTNAME_ALWAYS != -1 )); then

        [[ -r /etc/debian_chroot ]] && LP_HOST="($(< /etc/debian_chroot))"

        # Which host symbol should we use?
        if (( LP_ENABLE_FQDN )); then
            LP_HOST_SYMBOL="${_LP_FQDN_SYMBOL}"
        else
            LP_HOST_SYMBOL="${_LP_HOST_SYMBOL}"
        fi

        # If we are connected with a X11 support
        if [[ -n "$DISPLAY" ]]; then
            LP_HOST="${LP_COLOR_X11_ON}${LP_HOST}${LP_MARK_X11}${NO_COL}"
        else
            LP_HOST="${LP_COLOR_X11_OFF}${LP_HOST}${LP_MARK_X11}${NO_COL}"
        fi

        case "$(_lp_connection)" in
            lcl)
                if (( LP_HOSTNAME_ALWAYS )); then
                    LP_HOST+="${LP_COLOR_HOST}${LP_HOST_SYMBOL}${NO_COL}"
                else
                    # FIXME do we want to display the chroot if local?
                    LP_HOST="" # no hostname if local
                fi
                ;;
            ssh)
                LP_HOST+="${LP_COLOR_SSH}${LP_HOST_SYMBOL}${NO_COL}"
                ;;
            su)
                LP_HOST+="${LP_COLOR_SU}${LP_HOST_SYMBOL}${NO_COL}"
                ;;
            tel)
                LP_HOST+="${LP_COLOR_TELNET}${LP_HOST_SYMBOL}${NO_COL}"
                ;;
            *)
                LP_HOST+="${LP_HOST_SYMBOL}" # defaults to no color
                ;;
        esac
    fi
}

################
# Related jobs #
################

# Return the count of detached screens sessions and/or tmux sessions running
# on the host
# return: lp_detached_sessions; the number of detached sessions
_lp_detached_sessions() {
    local -i count=0
    (( _LP_ENABLE_SCREEN )) && count=$(screen -ls 2> /dev/null | \grep -c '[Dd]etach[^)]*)$')
    (( _LP_ENABLE_TMUX )) && count+=$(tmux list-sessions 2> /dev/null | \grep -cv 'attached')
    lp_detached_sessions=$count
    (( lp_detached_sessions ))
}

# Return the count of attached running jobs (started with $ myjob &) and/or
# stopped jobs (suspended with Ctrl-Z)
# return: lp_running_jobs; the number of running shell jobs
#         lp_stopped_jobs; the number of stopped shell jobs
_lp_jobcount() {
    local -i count
    # Count running jobs
    # The $(...) syntax strips trailing newlines, so add a character to the end
    # then remove it to prevent that. Otherwise 0 and 1 jobs look the same.
    jobs="$(jobs -r; printf x)"
    __lp_line_count "${jobs%x}"
    lp_running_jobs=$count

    # Count stopped jobs
    jobs="$(jobs -s; printf x)"
    __lp_line_count "${jobs%x}"
    lp_stopped_jobs=$count

    (( lp_running_jobs || lp_stopped_jobs ))
}

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
_lp_jobcount_color() {
    (( LP_ENABLE_JOBS )) || return 2

    lp_jobcount_color=

    _lp_detached_sessions && lp_jobcount_color="${LP_COLOR_JOB_D}${lp_detached_sessions}d${NO_COL}"

    _lp_jobcount
    if (( lp_running_jobs > 0 )); then
        [[ -n "$lp_jobcount_color" ]] && lp_jobcount_color+='/'
        lp_jobcount_color+="${LP_COLOR_JOB_R}${lp_running_jobs}&${NO_COL}"
    fi
    if (( lp_stopped_jobs > 0 )); then
        [[ -n "$lp_jobcount_color" ]] && lp_jobcount_color+='/'
        lp_jobcount_color+="${LP_COLOR_JOB_Z}${lp_stopped_jobs}z${NO_COL}"
    fi

    [[ -n "$lp_jobcount_color" ]]
}

######################
# VCS branch display #
######################

_lp_are_vcs_enabled() {
    local path
    for path in "${LP_DISABLED_VCS_PATHS[@]}"; do
        if [[ -n "$path" && "$PWD" == "$path"* ]]; then
            return 1
        fi
    done
    return 0
}

# Search upwards through a directory structure looking for a sign of a VCS
# repository. Used to avoid invoking VCS binaries to discover if in a repo.
# Checks $LP_DISABLED_VCS_PATH and returns false if a match is found.
# Otherwise returns the first matching repository.
# return: true if in repo, false if not (1) or path disabled (2)
#         lp_vcs_type; the string ID of the VCS controlling this directory.
#         lp_vcs_root; the path to the root of the found repository.
_lp_find_vcs() {
    if ! _lp_are_vcs_enabled; then
        lp_vcs_type="disabled"
        lp_vcs_root=""
        return 2
    fi

    lp_vcs_root="$PWD"
    while [[ -n "$lp_vcs_root" ]]; do
        for vcs in "${_LP_ENABLED_VCSS[@]}"; do
            if [[ -d "$lp_vcs_root/.$vcs" ]]; then
                lp_vcs_type="$vcs"

                if [[ "$lp_vcs_type" == git ]]; then
                    if [[ -n "${VCSH_DIRECTORY-}" ]]; then
                        lp_vcs_type="git-vcsh"
                    elif [[ -d "$lp_vcs_root/.git/svn" ]]; then
                        lp_vcs_type="git-svn"
                    fi
                fi

                return 0
            fi
        done

        lp_vcs_root="${lp_vcs_root%/*}"
    done

    lp_vcs_type=""
    lp_vcs_root=""
    return 1
}

# Set the prompt mark to ± if git, to ☿ if mercurial, to ‡ if subversion
# to # if root and else $
_lp_smart_mark() {
    local mark
    case "$LP_VCS_TYPE" in
        git)      mark="$LP_MARK_GIT" ;;
        git-svn)  mark="$LP_MARK_GIT$LP_MARK_SVN" ;;
        git-vcsh) mark="$LP_MARK_VCSH$LP_MARK_GIT$LP_MARK_VCSH" ;;
        hg)       mark="$LP_MARK_HG" ;;
        disabled) mark="$LP_MARK_DISABLED" ;;
        *)        mark="$LP_MARK_DEFAULT" ;;
    esac
    echo -nE "${mark}${NO_COL}"
}

# GIT #

# Get the branch name of the current directory
_lp_git_branch() {
    (( LP_ENABLE_GIT )) || return

    \git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return

    local branch ret
    # Recent versions of Git support the --short option for symbolic-ref, but
    # not 1.7.9 (Ubuntu 12.04)
    if branch="$(\git symbolic-ref -q HEAD)"; then
        __lp_escape "${branch#refs/heads/}"
        lp_vcs_branch="$ret"
    else
        # In detached head state, use commit instead
        # No escape needed
        lp_vcs_branch="$(\git rev-parse --short -q HEAD)"
    fi
}


# Display additional information if HEAD is in merging, rebasing
# or cherry-picking state
_lp_git_head_status() {
    local gitdir="${lp_vcs_root}/.git"
    if [[ -f "${gitdir}/MERGE_HEAD" ]]; then
        lp_vcs_head_status="MERGING"
    elif [[ -d "${gitdir}/rebase-apply" || -d "${gitdir}/rebase-merge" ]]; then
        lp_vcs_head_status="REBASING"
    elif [[ -f "${gitdir}/CHERRY_PICK_HEAD" ]]; then
        lp_vcs_head_status="CHERRY-PICKING"
    else
        return 1
    fi
}

_lp_git_stash_count() {
    local stashes count
    stashes="$(\git rev-parse --verify -q refs/stash; printf x)"
    __lp_line_count "${stashes%x}"
    lp_vcs_stash_count=$count
    (( lp_vcs_stash_count ))
}

_lp_git_untracked_files() {
    lp_vcs_untracked_files="$(LC_ALL=C \git status --porcelain 2>/dev/null | \grep -c '^??')"
    (( lp_vcs_untracked_files ))
}

# Set a color depending on the branch state:
# - green if the repository is up to date
# - yellow if there is some commits not pushed
# - red if there is changes to commit
#
# Add the number of pending commits and the impacted lines.
_lp_git_branch_color() {
    if [[ "$LP_ENABLE_GIT" != 0 && "$LP_ENABLE_OHMYGIT" != 0 ]]; then
        local omg_prompt
        if omg_prompt="$(_omg_build_prompt)"; then
            lp_vcs_branch_color="$omg_prompt"
            return
        fi
    fi

    _lp_git_branch || return $?
    local branch="$lp_vcs_branch"

    local end="$NO_COL"
    if _lp_git_head_status; then
        end=" ${LP_COLOR_CHANGES}${lp_vcs_head_status}$end"
    fi

    if _lp_git_untracked_files; then
        end="$LP_COLOR_CHANGES$LP_MARK_UNTRACKED$end"
    fi

    if _lp_git_stash_count; then
        end="$LP_COLOR_COMMITS$LP_MARK_STASH$end"
    fi

    local remote
    remote="$(\git config --get branch.${branch}.remote 2>/dev/null)"

    local has_commit=""
    local commit_ahead
    local commit_behind
    if [[ -n "$remote" ]]; then
        local remote_branch
        remote_branch="$(\git config --get branch.${branch}.merge)"
        if [[ -n "$remote_branch" ]]; then
            remote_branch=${remote_branch/refs\/heads/refs\/remotes\/$remote}
            commit_ahead="$(\git rev-list --count $remote_branch..HEAD 2>/dev/null)"
            commit_behind="$(\git rev-list --count HEAD..$remote_branch 2>/dev/null)"
            if [[ "$commit_ahead" -ne "0" && "$commit_behind" -ne "0" ]]; then
                has_commit="${LP_COLOR_COMMITS}+$commit_ahead${NO_COL}/${LP_COLOR_COMMITS_BEHIND}-$commit_behind${NO_COL}"
            elif [[ "$commit_ahead" -ne "0" ]]; then
                has_commit="${LP_COLOR_COMMITS}$commit_ahead${NO_COL}"
            elif [[ "$commit_behind" -ne "0" ]]; then
                has_commit="${LP_COLOR_COMMITS_BEHIND}-$commit_behind${NO_COL}"
            fi
        fi
    fi

    local ret
    local shortstat # only to check for uncommitted changes
    shortstat="$(LC_ALL=C \git diff --shortstat HEAD -- 2>/dev/null)"
    if [[ -n "$shortstat" ]]; then
        local u_stat # shorstat of *unstaged* changes
        u_stat="$(LC_ALL=C \git diff --shortstat 2>/dev/null)"
        u_stat=${u_stat/*changed, /} # removing "n file(s) changed"

        local i_lines # inserted lines
        if [[ "$u_stat" = *insertion* ]]; then
            i_lines=${u_stat/ inser*}
        else
            i_lines=0
        fi

        local d_lines # deleted lines
        if [[ "$u_stat" = *deletion* ]]; then
            d_lines=${u_stat/*\(+\), }
            d_lines=${d_lines/ del*/}
        else
            d_lines=0
        fi

        local has_lines
        has_lines="+$i_lines/-$d_lines"

        if [[ -n "$has_commit" ]]; then
            # Changes to commit and commits to push
            ret="${LP_COLOR_CHANGES}${branch}${NO_COL}${LP_MARK_VCS_OPEN}${LP_COLOR_DIFF}$has_lines${NO_COL},$has_commit${LP_MARK_VCS_CLOSE}"
        else
            ret="${LP_COLOR_CHANGES}${branch}${NO_COL}${LP_MARK_VCS_OPEN}${LP_COLOR_DIFF}$has_lines${NO_COL}${LP_MARK_VCS_CLOSE}" # changes to commit
        fi
    elif [[ -n "$has_commit" ]]; then
        # some commit(s) to push
        if [[ "$commit_behind" -gt "0" ]]; then
            ret="${LP_COLOR_COMMITS_BEHIND}${branch}${NO_COL}${LP_MARK_VCS_OPEN}$has_commit${LP_MARK_VCS_CLOSE}"
        else
            ret="${LP_COLOR_COMMITS}${branch}${NO_COL}${LP_MARK_VCS_OPEN}$has_commit${LP_MARK_VCS_CLOSE}"
        fi
    else
        ret="${LP_COLOR_UP}${branch}" # nothing to commit or push
    fi
    lp_vcs_branch_color="$ret$end"
}

# MERCURIAL #

# Get the branch name of the current directory
_lp_hg_branch() {
    (( LP_ENABLE_HG )) || return

    # We found an .hg folder, so we need to invoke hg and see if we're actually
    # in a repository.

    local branch ret
    if branch="$(hg branch 2>/dev/null)"; then
        __lp_escape "$branch"
        lp_vcs_branch="$ret"
    else
        return 1
    fi
}

# Set a color depending on the branch state:
# - green if the repository is up to date
# - red if there is changes to commit
# - TODO: yellow if there is some commits not pushed
_lp_hg_branch_color() {
    _lp_hg_branch || return $?
    local ret branch="$lp_vcs_branch"

    local has_untracked
    has_untracked=
    if hg status -u 2>/dev/null | \grep -q '^?' >/dev/null; then
        has_untracked="$LP_COLOR_CHANGES$LP_MARK_UNTRACKED"
    fi

    # Count local commits waiting for a push
    #
    # Unfortunately this requires contacting the remote, so this is always slow
    # => disabled  https://github.com/nojhan/liquidprompt/issues/217
    local -i commits
    #commits=$(hg outgoing --no-merges ${branch} 2>/dev/null | \grep -c '\(^changeset\:\)')
    commits=0

    # Check if there is some uncommitted stuff
    if [[ -z "$(hg status --quiet -n)" ]]; then
        if (( commits > 0 )); then
            # some commit(s) to push
            ret="${LP_COLOR_COMMITS}${branch}${NO_COL}${LP_MARK_VCS_OPEN}${LP_COLOR_COMMITS}$commits${NO_COL}${LP_MARK_VCS_CLOSE}${has_untracked}${NO_COL}"
        else
            # nothing to commit or push
            ret="${LP_COLOR_UP}${branch}${has_untracked}${NO_COL}"
        fi
    else
        local has_lines
        # Parse the last line of the diffstat-style output
        has_lines="$(hg diff --stat 2>/dev/null | sed -n '$ s!^.*, \([0-9]*\) .*, \([0-9]*\).*$!+\1/-\2!p')"
        if (( commits > 0 )); then
            # Changes to commit and commits to push
            ret="${LP_COLOR_CHANGES}${branch}${NO_COL}${LP_MARK_VCS_OPEN}${LP_COLOR_DIFF}$has_lines${NO_COL},${LP_COLOR_COMMITS}$commits${NO_COL}${LP_MARK_VCS_CLOSE}${has_untracked}${NO_COL}"
        else
            ret="${LP_COLOR_CHANGES}${branch}${NO_COL}${LP_MARK_VCS_OPEN}${LP_COLOR_DIFF}$has_lines${NO_COL}${LP_MARK_VCS_CLOSE}${has_untracked}${NO_COL}" # changes to commit
        fi
    fi
    lp_vcs_branch_color="$ret"
}

##########
# Title #
##########

_lp_title() {
    (( LP_ENABLE_TITLE )) || return

    # Get the current computed prompt as pure text
    echo -nE "${_LP_OPEN_ESC}${LP_TITLE_OPEN}"
    _lp_as_text "$1"
    echo -nE "${LP_TITLE_CLOSE}${_LP_CLOSE_ESC}"
}

#################
# Default theme #
#################

_lp_theme_activate() {
    # Default value for LP_PERM when LP_ENABLE_PERM is 0
    LP_PERM=${LP_MARK_PERM}   # without color

    if (( LP_ENABLE_TIME )); then
        # Never changes
        LP_TIME="${LP_COLOR_TIME}${_LP_TIME_SYMBOL}${NO_COL} "
    else
        LP_TIME=""
    fi
}

_lp_theme_directory() {
    # LP_PERM: shows a ":"
    # - colored in green if user has write permission on the current dir
    # - colored in red if not
    # - can set another symbol with LP_MARK_PERM
    if (( LP_ENABLE_PERM )); then
        if [[ -w "${PWD}" ]]; then
            LP_PERM="${LP_COLOR_WRITE}${LP_MARK_PERM}${NO_COL}"
        else
            LP_PERM="${LP_COLOR_NOWRITE}${LP_MARK_PERM}${NO_COL}"
        fi
    fi
}

_lp_theme_prompt() {
    if (( LP_ENABLE_ERR && lp_err != 0 )); then
        LP_ERR="$LP_MARK_SPACE$LP_COLOR_ERR$lp_err$NO_COL"
    else
        LP_ERR=""
    fi

    # left of main prompt: space at right
    if _lp_jobcount_color; then
        LP_JOBS="$lp_jobcount_color "
    else
        LP_JOBS=
    fi
    _lp_sudo_check

    # in main prompt: no space
    if [[ "$LP_ENABLE_PROXY,${http_proxy-}" = 1,?* ]]; then
        LP_PROXY="$LP_COLOR_PROXY$LP_MARK_PROXY$NO_COL"
    else
        LP_PROXY=""
    fi

    # Display the current Python virtual environment, if available
    if [[ "$LP_ENABLE_VIRTUALENV,${VIRTUAL_ENV-}${CONDA_DEFAULT_ENV-}" = 1,?* ]]; then
        if [[ -n "${VIRTUAL_ENV-}" ]]; then
            LP_VENV=" [${LP_COLOR_VIRTUALENV}${VIRTUAL_ENV##*/}${NO_COL}]"
        else
            LP_VENV=" [${LP_COLOR_VIRTUALENV}${CONDA_DEFAULT_ENV##*/}${NO_COL}]"
        fi
    else
        LP_VENV=""
    fi

    # Display the current software collections enabled, if available
    if [[ "$LP_ENABLE_SCLS,${X_SCLS-}" = 1,?* ]]; then
        LP_SCLS=" [${LP_COLOR_VIRTUALENV}${X_SCLS%"${X_SCLS##*[![:space:]]}"}${NO_COL}]"
    else
        LP_SCLS=""
    fi

    if _lp_find_vcs; then
        case "$lp_vcs_type" in
            git*)    _lp_git_branch_color;;
            hg)      _lp_hg_branch_color;;
        esac
        [[ -n "$lp_vcs_branch_color" ]] && LP_VCS=" $lp_vcs_branch_color"
    else
        LP_VCS=""
    fi

    # end of the prompt line: double spaces
    LP_MARK="$(_lp_sr "$(_lp_smart_mark $lp_vcs_type)")"

    if [[ -f "${LP_PS1_FILE-}" ]]; then
        source "$LP_PS1_FILE"
    fi

    if [[ -z "${LP_PS1-}" ]]; then
        # add time and jobs
        PS1="${LP_TIME}${LP_JOBS}"
        # add user, host and permissions colon
        PS1+="${LP_BRACKET_OPEN}${LP_USER}${LP_HOST}${LP_PERM}"

        PS1+="${LP_PWD}${LP_BRACKET_CLOSE}${LP_SCLS}${LP_VENV}${LP_PROXY}"

        # Add VCS infos
        # If root, the info has not been collected unless LP_ENABLE_VCS_ROOT
        # is set.
        PS1+="${LP_VCS}"

        # add return code and prompt mark
        PS1+="${LP_ERR}${LP_MARK_PREFIX}${LP_COLOR_MARK}${LP_MARK}"

        # "invisible" parts
        # Get the current prompt on the fly and make it a title
        LP_TITLE="$(_lp_title "${LP_TAG:-"$PS1"}")"

        # Insert it in the prompt
        PS1="${LP_TITLE}${PS1}"
    else
        PS1=$LP_PS1
    fi
}

########################
# Construct the prompt #
########################

_lp_set_prompt() {
    # Display the return value of the last command, if different from zero
    # As this get the last returned code, it should be called first
    local -i lp_err=$?

    # bash: execute the old prompt hook
    eval "$LP_OLD_PROMPT_COMMAND"

    # if change of working directory
    if [[ "${LP_OLD_PWD-}" != "LP:$PWD" ]]; then
        _lp_shorten_path   # set LP_PWD

        _lp_theme_directory

        # Prefix with 'LP:' to prevent Zsh with AUTO_NAME_DIRS enabled using
        # this var as a name for the working directory, that will be used by
        # the '%' and related prompt sequences.
        # See https://github.com/nojhan/liquidprompt/issues/124 for details.
        LP_OLD_PWD="LP:$PWD"
    fi

    _lp_theme_prompt
}

prompt_tag() {
    export LP_TAG="$1"
}

prompt_fulleval() {
    LP_OLD_PWD=""
}

# Activate Liquid Prompt
prompt_on() {
    # Reset so all PWD dependent variables are computed after loading
    LP_OLD_PWD=""

    # if Liquid Prompt has not been already set
    if [[ -z "${LP_OLD_PS1-}" ]]; then
        LP_TAG=""
        LP_OLD_PS1="$PS1"
        if $_LP_SHELL_bash; then
            LP_OLD_PROMPT_COMMAND="$PROMPT_COMMAND"
            _LP_OLD_SHOPT="$(shopt -p promptvars)"
        else # zsh
            LP_OLD_PROMPT_COMMAND=""
            _LP_ZSH_PROMPT_THEME=""
            if [[ -n "$prompt_theme" && "$prompt_theme" != off ]]; then
                _LP_ZSH_PROMPT_THEME="$prompt_theme"
                # Disable the prompt to disable its precmd hook
                prompt off
            fi
            _LP_OLD_SETOPT=()
            # Dump option names: echo ${(ko)options}
            for o in promptpercent promptbang promptsubst
            do
                if [[ "${options[$o]}" = on ]]; then
                    _LP_OLD_SETOPT+=$o
                else
                    _LP_OLD_SETOPT+=no$o
                fi
            done
        fi
    fi
    if $_LP_SHELL_bash; then
        # Prevent some cases where the user shoots in his own foot.
        # PROMPT_COMMAND is not exported by default, but some users
        # incorrectly export it from their profile/bashrc (GitHub #450),
        # so we preventively UNexport it.
        # TODO: warn the user if it was exported
        if (( ${BASH_VERSINFO[0]:-0} > 4 || ( ${BASH_VERSINFO[0]:-0} == 4 && ${BASH_VERSINFO[1]:-0} >= 2 ) )); then
            # -g is only available since bash 4.2
            declare -g +x PROMPT_COMMAND
        fi

        # Disable parameter/command expansion from PS1
        shopt -u promptvars
        PROMPT_COMMAND=_lp_set_prompt
    else # zsh
        # Set options that affect PS1 evaluation
        # Disable parameter/command expansion; enable percent expansion
        setopt promptpercent nopromptbang nopromptsubst
        add-zsh-hook precmd _lp_set_prompt
    fi
}

# Come back to the old prompt
prompt_off() {
    PS1=$LP_OLD_PS1
    if $_LP_SHELL_bash; then
        eval "$_LP_OLD_SHOPT"
        PROMPT_COMMAND="$LP_OLD_PROMPT_COMMAND"
    else # zsh
        add-zsh-hook -d precmd _lp_set_prompt
        setopt ${_LP_OLD_SETOPT}
        (( ${#_LP_ZSH_PROMPT_THEME} )) && prompt $_LP_ZSH_PROMPT_THEME
    fi
}

# Use an empty prompt: just the ❯ mark
prompt_OFF() {
    PS1="❯ "
    if $_LP_SHELL_bash; then
        shopt -u promptvars
        PROMPT_COMMAND="$LP_OLD_PROMPT_COMMAND"
    else # zsh
        add-zsh-hook -d precmd _lp_set_prompt
        setopt promptpercent nopromptbang nopromptsubst
    fi
}

# By default, sourcing liquidprompt will activate Liquid Prompt
lp_activate
prompt_on

# vim: set et sts=4 sw=4 tw=120 ft=sh:
