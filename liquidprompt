################################################################################
# LIQUID PROMPT
# An intelligent and non-intrusive prompt for Bash and zsh
################################################################################

# Licensed under the AGPL version 3
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Issue #161: do not load if not an interactive shell
# Do not exit if '--no-activate' flag was passed, as it overrides this check
[ "x${-##*i}" = "x$-" ] || [ -z "${TERM-}" ] || [ "x${TERM-}" = xdumb ] || [ "x${TERM-}" = xunknown ] && [ "x${1-}" != "x--no-activate" ] && return

if test -n "${BASH_VERSION-}"; then
    _LP_SHELL_bash=1
    _LP_SHELL_zsh=0
    _LP_OPEN_ESC="\["
    _LP_CLOSE_ESC="\]"

    _LP_MARK_SYMBOL='$'

    # Escape the given strings
    # Must be used for all strings injected in PS1 that may comes from remote sources,
    # like $PWD, Git branch names...
    __lp_escape() {
        ret="${1//\\/\\\\}"
        if shopt -q promptvars ; then
            ret="${ret//\$/\\\$}"
            ret="${ret//\`/\\\`}"
        fi
    }

    __lp_strip_escapes() {
        ret="$1"
        while [[ "$ret" == *"$_LP_OPEN_ESC"* ]]; do
            ret="${ret%%"$_LP_OPEN_ESC"*}${ret#*"$_LP_CLOSE_ESC"}"
        done

        ret="${ret//\\\\/\\}"
        if shopt -q promptvars ; then
            ret="${ret//\\\$/\$}"
            ret="${ret//\\\`/\`}"
        fi
    }
elif test -n "${ZSH_VERSION-}"; then
    _LP_SHELL_bash=0
    _LP_SHELL_zsh=1
    _LP_OPEN_ESC="%{"
    _LP_CLOSE_ESC="%}"

    _LP_MARK_SYMBOL='%%'

    __lp_escape() {
        ret="${1//\\/\\\\}"
        ret="${ret//\%/%%}"
        if [[ -o promptbang ]]; then
            ret="${ret//!/!!}"
        fi
        if [[ -o promptsubst ]]; then
            ret="${ret//\$/\\\$}"
            ret="${ret//\`/\\\`}"
        fi
    }

    __lp_strip_escapes() {
        ret="${(S)1//"${_LP_OPEN_ESC}"*"${_LP_CLOSE_ESC}"}"
        ret="${ret//\\\\/\\}"
        ret="${ret//\%\%/%}"
        if [[ -o promptbang ]]; then
            ret="${ret//!!/!}"
        fi
        if [[ -o promptsubst ]]; then
            ret="${ret//\\\$/\$}"
            ret="${ret//\\\`/\`}"
        fi
    }
else
    echo "liquidprompt: shell not supported" >&2
    return
fi

__lp_array_contains() {
    local target="$1"
    shift

    for element; do
        if [[ $element == "$target" ]]; then
            return 0
        fi
    done
    return 1
}

#################
# CONFIGURATION #
#################

# Load the user configuration and setup defaults.
__lp_source_config() {
    local lp_terminal_format af_color='' ab_color=''

    # Colors: variables are local so they will have a value only
    # during config loading and will not conflict with other values
    # with the same names defined by the user outside the config.
    local BOLD="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${_LP_CLOSE_ESC}"

    # Foreground colors
    __lp_foreground_color 0
    local BLACK="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GRAY="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 1
    local RED="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_RED="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"
    __lp_foreground_color 0
    __lp_background_color 1
    local WARN_RED="${_LP_OPEN_ESC}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    __lp_foreground_color 7
    local CRIT_RED="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    __lp_foreground_color 3
    local DANGER_RED="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${ab_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 2
    local GREEN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GREEN="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 3
    local YELLOW="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_YELLOW="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 4
    local BLUE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_BLUE="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 5
    local PURPLE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local MAGENTA="${PURPLE}"
    local PINK="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_PURPLE="${PINK}"
    local BOLD_MAGENTA="${PINK}"

    __lp_foreground_color 6
    local CYAN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_CYAN="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 7
    local WHITE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_WHITE="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    # NO_COL is special: it will be used at runtime, not just during config loading
    NO_COL="${_LP_OPEN_ESC}${_LP_TI_RESET-}${_LP_CLOSE_ESC}"

    # Default values (globals)
    LP_TIME_FORMAT=${LP_TIME_FORMAT:-"%H:%M:%S"}
    LP_SHLVL_THRESHOLD=${LP_SHLVL_THRESHOLD:-2}
    LP_HIDE_EMPTY_ERROR=${LP_HIDE_EMPTY_ERROR:-1}
    LP_PATH_LENGTH=${LP_PATH_LENGTH:-35}
    LP_PATH_KEEP=${LP_PATH_KEEP:-2}
    LP_PATH_CHARACTER_KEEP=${LP_PATH_CHARACTER_KEEP:-3}
    LP_PATH_METHOD=${LP_PATH_METHOD:-truncate_chars_from_path_left}
    LP_PATH_GIT_ROOT=${LP_PATH_GIT_ROOT:-1}
    LP_HOSTNAME_ALWAYS=${LP_HOSTNAME_ALWAYS:-0}
    LP_HOSTNAME_METHOD=${LP_HOSTNAME_METHOD:-short}
    LP_USER_ALWAYS=${LP_USER_ALWAYS:-0}
    LP_PS1=${LP_PS1:-""}
    LP_PS1_PREFIX=${LP_PS1_PREFIX:-""}
    LP_PS1_POSTFIX=${LP_PS1_POSTFIX:-""}

    LP_ENABLE_DISPLAY=${LP_ENABLE_DISPLAY:-1}
    LP_ENABLE_CHROOT=${LP_ENABLE_CHROOT:-1}
    LP_ENABLE_PERM=${LP_ENABLE_PERM:-1}
    LP_ENABLE_SHORTEN_PATH=${LP_ENABLE_SHORTEN_PATH:-1}
    LP_ENABLE_DIRSTACK=${LP_ENABLE_DIRSTACK:-0}
    LP_ENABLE_PROXY=${LP_ENABLE_PROXY:-0}
    LP_ENABLE_JOBS=${LP_ENABLE_JOBS:-1}
    LP_ENABLE_DETACHED_SESSIONS=${LP_ENABLE_DETACHED_SESSIONS:-1}
    LP_ENABLE_GIT=${LP_ENABLE_GIT:-1}
    LP_ENABLE_GIT_ROOT=${LP_ENABLE_GIT_ROOT:-0}
    LP_ENABLE_TIME=${LP_ENABLE_TIME:-0}
    LP_ENABLE_TITLE=${LP_ENABLE_TITLE:-1}
    LP_ENABLE_SCREEN_TITLE=${LP_ENABLE_SCREEN_TITLE:-1}
    LP_ENABLE_SUDO=${LP_ENABLE_SUDO:-1}
    LP_ENABLE_COLOR=${LP_ENABLE_COLOR:-1}
    LP_ENABLE_ERROR=${LP_ENABLE_ERROR:-1}
    LP_ENABLE_SHLVL=${LP_ENABLE_SHLVL:-1}
    LP_DISABLED_GIT_PATHS=( ${LP_DISABLED_GIT_PATHS[@]+"${LP_DISABLED_GIT_PATHS[@]}"} )

    LP_MARK_DEFAULT="${LP_MARK_DEFAULT:-$_LP_MARK_SYMBOL}"
    LP_MARK_PROXY="${LP_MARK_PROXY:-"↥"}"
    LP_MARK_SVN="${LP_MARK_SVN:-"‡"}"
    LP_MARK_GIT="${LP_MARK_GIT:-"±"}"
    LP_MARK_VCSH="${LP_MARK_VCSH:-"|"}"
    LP_MARK_DISABLED="${LP_MARK_DISABLED:-"⌀"}"
    LP_MARK_GIT_HEAD_STATUS="${LP_MARK_GIT_HEAD_STATUS:-"⚡"}"
    LP_MARK_GIT_DETACHED="${LP_MARK_GIT_DETACHED:-"#"}"
    LP_MARK_GIT_DIVERGED="${LP_MARK_GIT_DIVERGED:-"⌥"}"
    LP_MARK_GIT_FAST_FORWARD="${LP_MARK_GIT_FAST_FORWARD:-"»"}"
    LP_MARK_GIT_PUSH="${LP_MARK_GIT_PUSH:-"⌅"}"
    LP_MARK_GIT_STASH="${LP_MARK_GIT_STASH:-"✸"}"
    LP_MARK_GIT_UNTRACKED="${LP_MARK_GIT_UNTRACKED:-"~"}"
    LP_MARK_GIT_MODIFICATIONS="${LP_MARK_GIT_MODIFICATIONS:-"✎"}"
    LP_MARK_GIT_DELETIONS="${LP_MARK_GIT_DELETIONS:-"−"}"
    LP_MARK_GIT_ADDS="${LP_MARK_GIT_ADDS:-"+"}"
    LP_MARK_GIT_CACHED_MODIFICATIONS="${LP_MARK_GIT_CACHED_MODIFICATIONS:-"±"}"
    LP_MARK_GIT_CACHED_DELETIONS="${LP_MARK_GIT_CACHED_DELETIONS:-"×"}"
    LP_MARK_GIT_COMMIT="${LP_MARK_GIT_COMMIT:-"➜"}"
    LP_MARK_GIT_TAG="${LP_MARK_GIT_TAG:-"☗"}"
    LP_MARK_GIT_MERGE="${LP_MARK_GIT_MERGE:-"۷"}"
    LP_MARK_GIT_REBASE="${LP_MARK_GIT_REBASE:-"↯"}"
    LP_MARK_BRACKET_OPEN="${LP_MARK_BRACKET_OPEN:-"["}"
    LP_MARK_BRACKET_CLOSE="${LP_MARK_BRACKET_CLOSE:-"]"}"
    LP_MARK_SHORTEN_PATH="${LP_MARK_SHORTEN_PATH:-" … "}"
    LP_MARK_PREFIX="${LP_MARK_PREFIX:-" "}"
    LP_MARK_PERM="${LP_MARK_PERM:-":"}"
    LP_MARK_X11="${LP_MARK_X11:-"@"}"
    LP_MARK_DIRSTACK="${LP_MARK_DIRSTACK:-"⚞"}"
    LP_MARK_SHLVL="${LP_MARK_SHLVL:-"└"}"
    LP_MARK_JOBS_SEPARATOR="${LP_MARK_JOBS_SEPARATOR:-"/"}"

    LP_COLOR_PATH=${LP_COLOR_PATH:-$NO_COL}
    LP_COLOR_PATH_ROOT=${LP_COLOR_PATH_ROOT:-$BOLD_YELLOW}
    lp_terminal_format 12 0 0 0 8
    LP_COLOR_PATH_SEPARATOR=${LP_COLOR_PATH_SEPARATOR:-$lp_terminal_format}
    LP_COLOR_PATH_SHORTENED=${LP_COLOR_PATH_SHORTENED:-$lp_terminal_format}
    LP_COLOR_PATH_GIT_ROOT=${LP_COLOR_PATH_GIT_ROOT:-$BOLD_BLUE}
    LP_COLOR_PATH_LAST_DIR=${LP_COLOR_PATH_LAST_DIR:-$BOLD_WHITE}
    LP_COLOR_DIRSTACK=${LP_COLOR_DIRSTACK:-$BOLD_YELLOW}
    LP_COLOR_PROXY=${LP_COLOR_PROXY:-$BOLD_BLUE}
    LP_COLOR_JOB_D=${LP_COLOR_JOB_D:-$YELLOW}
    LP_COLOR_JOB_R=${LP_COLOR_JOB_R:-$BOLD_YELLOW}
    LP_COLOR_JOB_Z=${LP_COLOR_JOB_Z:-$BOLD_YELLOW}
    LP_COLOR_ERR=${LP_COLOR_ERR:-$PURPLE}
    LP_COLOR_MARK=${LP_COLOR_MARK:-$BOLD}
    LP_COLOR_MARK_ROOT=${LP_COLOR_MARK_ROOT:-$BOLD_RED}
    LP_COLOR_MARK_SUDO=${LP_COLOR_MARK_SUDO:-$LP_COLOR_MARK_ROOT}
    LP_COLOR_USER_LOGGED=${LP_COLOR_USER_LOGGED:-""}
    LP_COLOR_USER_ALT=${LP_COLOR_USER_ALT:-$BOLD}
    LP_COLOR_USER_ROOT=${LP_COLOR_USER_ROOT:-$BOLD_YELLOW}
    LP_COLOR_HOST=${LP_COLOR_HOST:-""}
    LP_COLOR_SSH=${LP_COLOR_SSH:-$BLUE}
    LP_COLOR_SU=${LP_COLOR_SU:-$BOLD_YELLOW}
    LP_COLOR_TELNET=${LP_COLOR_TELNET:-$WARN_RED}
    LP_COLOR_X11_ON=${LP_COLOR_X11_ON:-$GREEN}
    LP_COLOR_X11_OFF=${LP_COLOR_X11_OFF:-$YELLOW}
    LP_COLOR_WRITE=${LP_COLOR_WRITE:-$GREEN}
    LP_COLOR_NOWRITE=${LP_COLOR_NOWRITE:-$RED}
    LP_COLOR_GIT_HEAD_STATUS=${LP_COLOR_GIT_HEAD_STATUS:-$RED}
    LP_COLOR_GIT_COMMITS=${LP_COLOR_GIT_COMMITS:-$YELLOW}
    LP_COLOR_GIT_LOCAL=${LP_COLOR_GIT_LOCAL:-$BLUE}
    LP_COLOR_GIT_UPSTREAM=${LP_COLOR_GIT_UPSTREAM:-$YELLOW}
    LP_COLOR_GIT_DETACHED=${LP_COLOR_GIT_DETACHED:-$RED}
    LP_COLOR_GIT_MARK_DETACHED=${LP_COLOR_GIT_MARK_DETACHED:-$BOLD_RED}
    LP_COLOR_GIT_DIVERGED=${LP_COLOR_GIT_DIVERGED:-$BOLD_RED}
    LP_COLOR_GIT_FAST_FORWARD=${LP_COLOR_GIT_FAST_FORWARD:-$BOLD_BLUE}
    LP_COLOR_GIT_PUSH=${LP_COLOR_GIT_PUSH:-$BOLD_GREEN}
    LP_COLOR_GIT_STASH=${LP_COLOR_GIT_STASH:-$YELLOW}
    LP_COLOR_GIT_UNTRACKED=${LP_COLOR_GIT_UNTRACKED:-$BOLD_RED}
    LP_COLOR_GIT_MODIFICATIONS=${LP_COLOR_GIT_MODIFICATIONS:-$BOLD_RED}
    LP_COLOR_GIT_DELETIONS=${LP_COLOR_GIT_DELETIONS:-$BOLD_RED}
    LP_COLOR_GIT_ADDS=${LP_COLOR_GIT_ADDS:-$BOLD_BLUE}
    LP_COLOR_GIT_CACHED_MODIFICATIONS=${LP_COLOR_GIT_CACHED_MODIFICATIONS:-$BOLD_BLUE}
    LP_COLOR_GIT_CACHED_DELETIONS=${LP_COLOR_GIT_CACHED_DELETIONS:-$BOLD_BLUE}
    LP_COLOR_GIT_COMMIT=${LP_COLOR_GIT_COMMIT:-$GREEN}
    LP_COLOR_GIT_TAG=${LP_COLOR_GIT_TAG:-$PURPLE}
    LP_COLOR_TIME=${LP_COLOR_TIME:-$BLUE}
    LP_COLOR_IN_MULTIPLEXER=${LP_COLOR_IN_MULTIPLEXER:-$BOLD_BLUE}
    LP_COLOR_IN_LOCAL=${LP_COLOR_IN_LOCAL:-$WHITE}
    LP_COLOR_SHLVL=${LP_COLOR_SHLVL:-$BOLD_GREEN}
}

# Initialize features based on the user config.
lp_activate() {
    if (( _LP_SHELL_zsh )); then
        # For ZSH, autoload required functions
        autoload -Uz add-zsh-hook
    fi

    # Disable hooks that we don't need if features will be disabled.
    __lp_disable_hooks

    # TermInfo feature detection
    _lp_af_colors=() _lp_ab_colors=()

    __lp_foreground_color() { return 2 ; }
    __lp_background_color() { return 2 ; }

    # TODO handle this case better. With no colors, no need for any escaping
    if ! command -v tput >/dev/null; then
        echo "liquidprompt: 'tput' not available; will not be able to format terminal" >&2
        LP_ENABLE_COLOR=0
    else
        _LP_TI_RESET="$( { tput sgr0 || tput me ; } 2>/dev/null )"
        _LP_TI_BOLD="$( { tput bold || tput md ; } 2>/dev/null )"
        _LP_TI_UNDERLINE="$( { tput smul || tput us ; } 2>/dev/null )"
        _LP_TI_COLORS="$( tput colors 2>/dev/null )"
        _LP_TI_COLORS=${_LP_TI_COLORS:-8}

        if tput setaf 0 >/dev/null 2>&1; then
            __lp_foreground_color() { af_color="${_lp_af_colors[$1+1]:=$(tput setaf "$1")}"; }
        elif tput AF 0 >/dev/null 2>&1; then
            # FreeBSD
            __lp_foreground_color() { af_color="${_lp_af_colors[$1+1]:=$(tput AF "$1")}"; }
        elif tput AF 0 0 0 >/dev/null 2>&1; then
            # OpenBSD
            __lp_foreground_color() { af_color="${_lp_af_colors[$1+1]:=$(tput AF "$1" 0 0)}"; }
        else
            echo "liquidprompt: terminal '${TERM-}' does not support foreground colors" >&2
        fi
        if tput setab 0 >/dev/null 2>&1; then
            __lp_background_color() { ab_color="${_lp_ab_colors[$1+1]:=$(tput setab "$1")}"; }
        elif tput AB 0 >/dev/null 2>&1; then
            # FreeBSD
            __lp_background_color() { ab_color="${_lp_ab_colors[$1+1]:=$(tput AB "$1")}"; }
        elif tput AB 0 0 0 >/dev/null 2>&1; then
            # OpenBSD
            __lp_background_color() { ab_color="${_lp_ab_colors[$1+1]:=$(tput AB "$1" 0 0)}"; }
        else
            echo "liquidprompt: terminal '${TERM-}' does not support background colors" >&2
        fi
    fi

    __lp_source_config "$@"

    # Disable feature if the tool is not installed
    _lp_require_tool()
    {
        # zsh does not allow quoting here.
        (( LP_ENABLE_$1 )) && { command -v "$2" >/dev/null || eval "LP_ENABLE_$1=0" ; }
    }

    _lp_require_tool TIME date
    _lp_require_tool GIT git

    unset -f _lp_require_tool

    _LP_ENABLE_PREEXEC=$((
        LP_HIDE_EMPTY_ERROR \
    ))

    if (( LP_ENABLE_DETACHED_SESSIONS )); then
        command -v screen >/dev/null ; _LP_ENABLE_SCREEN=$(( ! $? ))
        command -v tmux >/dev/null   ; _LP_ENABLE_TMUX=$(( ! $? ))
    fi

    # Use standard path symbols inside Midnight Commander
    [[ -n "${MC_SID-}" ]] && LP_ENABLE_SHORTEN_PATH=0

    # If we are running in a terminal multiplexer, special title escapes
    if _lp_multiplexer; then
        (( LP_ENABLE_TITLE = LP_ENABLE_TITLE && LP_ENABLE_SCREEN_TITLE ))
        LP_TITLE_OPEN=$'\Ek'
        LP_TITLE_CLOSE=$'\E\\'
    else
        LP_TITLE_OPEN=$'\E]0;'
        LP_TITLE_CLOSE=$'\a'
    fi

    [[ "_${TERM-}" == _linux* ]] && LP_ENABLE_TITLE=0

    ###############
    # Who are we? #
    ###############

    _lp_user
    local -i user="$?"

    if (( user < 2 )); then  # if user is not root
        if (( LP_ENABLE_SUDO )); then
            command -v sudo >/dev/null || LP_ENABLE_SUDO=0
        fi

        if (( user == 1 )); then
            LP_COLOR_USER=$LP_COLOR_USER_ALT
        else
            LP_COLOR_USER=$LP_COLOR_USER_LOGGED
        fi
    else # root!
        LP_ENABLE_SUDO=0
        if (( ! LP_ENABLE_GIT_ROOT )); then
            LP_DISABLED_GIT_PATHS=("/")
        fi

        LP_MARK_DEFAULT='#'

        LP_COLOR_MARK=$LP_COLOR_MARK_ROOT
        LP_COLOR_PATH=$LP_COLOR_PATH_ROOT
        LP_COLOR_USER=$LP_COLOR_USER_ROOT
    fi

    _lp_default_theme_activate
    prompt_on
}

#####################
# Utility Functions #
#####################

# Count the number of lines in the input string. A faster substitute for 'wc -l'.
__lp_line_count() {
  local var="${1//[!$'\n']}"
  count=${#var}
}

# Return $PWD with $HOME at the start replaced by "~".
__lp_pwd_tilde() {  # [path]
    # Needs to be in a variable, as different versions of Bash treat '~' in a
    # substitution differently
    local _path="${1:-$PWD}" tilde="~"
    lp_pwd_tilde="${_path/#$HOME/$tilde}"
}

# Generates a terminal escape sequence to format the terminal.
lp_terminal_format() {  # fg, bg, bold, underline, fallback_fg, fallback_bg
    lp_terminal_format=
    (( LP_ENABLE_COLOR )) || return 2

    local af_color ab_color fg bg previous_af_color
    fg=$1
    bg=${2:-"-1"}
    previous_af_color=${_lp_last_af_color-}

    lp_terminal_format=${_LP_OPEN_ESC}${_LP_TI_RESET}

    if (( fg >= _LP_TI_COLORS )) && [[ -n ${5-} ]]; then
        _lp_last_af_color=$5
    elif (( fg == -2 )); then
        :  # do nothing, _lp_last_af_color already correct
    elif (( fg == -3 )); then
        _lp_last_af_color=$_lp_last_ab_color
    elif (( fg >= 0 )); then
        _lp_last_af_color=$fg
    else  # -1
        _lp_last_af_color=-1
    fi

    if (( ${_lp_last_af_color:-"-1"} >= 0 )); then
        __lp_foreground_color "$_lp_last_af_color" && lp_terminal_format+=$af_color
    fi

    if (( bg >= _LP_TI_COLORS )) && [[ -n ${6-} ]]; then
        _lp_last_ab_color=$6
    elif (( bg == -2 )); then
        :  # do nothing, _lp_last_ab_color already correct
    elif (( bg == -3 )); then
        _lp_last_ab_color=$previous_af_color
    elif (( bg >= 0 )); then
        _lp_last_ab_color=$bg
    else  # -1
        _lp_last_ab_color=-1
    fi

    if (( ${_lp_last_ab_color:-"-1"} >= 0 )); then
        __lp_background_color "$_lp_last_ab_color" && lp_terminal_format+=$ab_color
    fi

    # It turns out there are sequences to reset bold and underline to normal
    # (\E[22m and \E[24m in xterm), but they aren't universally supported. This
    # means we must reset to all defaults then enable if they are wanted.
    # Explicit is safer anyway.
    if (( ${3:-0} )); then
        lp_terminal_format+=$_LP_TI_BOLD
    fi

    if (( ${4:-0} )); then
        lp_terminal_format+=$_LP_TI_UNDERLINE
    fi

    lp_terminal_format+=$_LP_CLOSE_ESC
}

##########################
# Working Directory Path #
##########################

__lp_get_unique_directory() {
    local directory="${1##*/}" root="${1%/*}"
    local -a matching
    local -i i
    for (( i=1; i < ${#directory}; i++ )); do
        lp_unique_directory=${directory:0:$i}
        matching=("${root}/${lp_unique_directory}"*/)
        if (( ${#matching[@]} == 1 )); then
            return 0
        fi
    done

    return 1
}

__lp_end_path_left_shortening() {
    if (( is_shortening )); then
        shortened_path_length+=${#separator}
        if (( shortened_path_length < unshortened_path_length )); then
            lp_path_format+="${shortened_directory_format}${LP_MARK_SHORTEN_PATH}"
            # This indescriminate adding of a separator can sometimes mean the path
            # is slightly longer than it should be, but it is more clear.
            lp_path_format+="${separator_format}${separator}"
            lp_path+="${LP_MARK_SHORTEN_PATH}/"
        else
            lp_path+=$unshortened_path_shorten_string
            lp_path_format+=$unshortened_path_format_shorten_string
            shortened_path_length=$unshortened_path_length
        fi
        is_shortening=0
    fi
}

# methods:
#   truncate_chars_from_path_left
#   truncate_chars_from_dir_middle
#   truncate_chars_from_dir_right
#   truncate_chars_to_unique_dir
#   truncate_to_last_dir
_lp_path_format() {
    local path_format="${1-$LP_COLOR_PATH}"
    local last_directory_format="${2:-$path_format}"
    local git_root_format="${3:-$last_directory_format}"
    local shortened_directory_format="${4:-$path_format}"
    local separator="${5-"/"}"
    local separator_format="${6-}"

    lp_path=
    lp_path_format=

    local ret

    local lp_pwd_tilde
    __lp_pwd_tilde
    local display_path="$lp_pwd_tilde"

    local -i path_length="${#display_path}"

    local lp_git_root lp_git_dir lp_git_type lp_git_subtype
    local git_root_directory=
    if (( LP_PATH_GIT_ROOT )) && _lp_find_git; then
        __lp_pwd_tilde "$lp_git_root"
        git_root_directory=$lp_pwd_tilde
    fi

    if [[ $path_length -eq 1 || $LP_PATH_METHOD == "truncate_to_last_dir" ]]; then
        if [[ $path_length -gt 1 ]]; then
            lp_path=${display_path##*/}
        else
            # only root or home to show
            lp_path=$display_path
        fi

        __lp_escape "$lp_path"

        if [[ $display_path == "$git_root_directory" ]]; then
            lp_path_format="${git_root_format}${ret}"
        else
            lp_path_format="${last_directory_format}${ret}"
        fi

        return
    else
        if [[ $separator != "/" && ${display_path:0:1} == "/" ]]; then
            # The root directory ('/') becomes a directory name instead of a leading separator
            # Add one to account for the first / needing to be both replaced and shown
            path_length+=1
        fi
        if [[ ${#separator} -gt 1 ]]; then
            # Add length to account for multichar separators
            local slash_count="${display_path//[!\/]}"
            path_length+=$(( ${#slash_count} * ( ${#separator} - 1 ) ))
        fi
    fi

    local path_to_proccess="${display_path}/" current_path="" current_directory="" lp_unique_directory

    local -i max_len=$(( ${COLUMNS:-80} * LP_PATH_LENGTH / 100 )) directory_count=0 needed_length
    local -i shortened_path_length="$path_length" is_shortening=0 unshortened_path_length
    local unshortened_path_shorten_string unshortened_path_format_shorten_string shortened_path

    while [[ -n $path_to_proccess ]]; do

        if [[ ${path_to_proccess:0:1} == "/" ]]; then
            # Start of root
            current_directory="/"
        else
            current_directory=${path_to_proccess%%/*}
            if [[ -n $current_path && $current_path != "/" ]]; then
                current_path+="/"
            fi
        fi

        directory_count+=1
        current_path+=${current_directory}
        path_to_proccess=${path_to_proccess#*/}

        if [[ $current_path == "$git_root_directory" ]]; then
            __lp_end_path_left_shortening
            # No shortening
            lp_path+=$current_directory
            __lp_escape "$current_directory"
            lp_path_format+="${git_root_format}${ret}"
        elif [[ -z $path_to_proccess ]]; then
            __lp_end_path_left_shortening
            # Last directory
            lp_path+=$current_directory
            __lp_escape "$current_directory"
            lp_path_format+="${last_directory_format}${ret}"
        elif (( LP_ENABLE_SHORTEN_PATH && directory_count > LP_PATH_KEEP \
            && ( shortened_path_length > max_len || ( shortened_path_length >= max_len && is_shortening ) ) )); then

            if [[ $LP_PATH_METHOD == "truncate_chars_to_unique_dir" ]] && \
                __lp_get_unique_directory "$current_path"; then

                lp_path+=$lp_unique_directory
                __lp_escape "$lp_unique_directory"
                lp_path_format+="${shortened_directory_format}${ret}"
                shortened_path_length=$(( shortened_path_length - ${#current_directory} + ${#lp_unique_directory} ))
            elif [[ $LP_PATH_METHOD == "truncate_chars_from_path_left" ]]; then
                # The only way to know if this consecutive directory shortening
                # will actually shorten the path is to both do it and do not and
                # compare at the end.

                if (( ! is_shortening )); then
                    unshortened_path_shorten_string=
                    unshortened_path_format_shorten_string=
                    unshortened_path_length=$shortened_path_length
                    shortened_path_length+=${#LP_MARK_SHORTEN_PATH}
                fi
                needed_length=$(( shortened_path_length - max_len ))

                unshortened_path_shorten_string+="${current_directory}/"
                unshortened_path_format_shorten_string+="${path_format}${current_directory}${separator_format}${separator}"

                if (( needed_length >= ${#current_directory} )); then
                    # One directory was not enough, need to shorten more.
                    # Shorten by current directory length plus separator.
                    shortened_path_length=$(( shortened_path_length - ${#current_directory} - ${#separator} ))
                    is_shortening=1
                else
                    # Do not need to check if the shortened version is actually shorter.
                    # If we got to here, it wasn't a forced ending, which means it is.
                    shortened_path_length=$(( shortened_path_length - needed_length ))

                    shortened_path="${LP_MARK_SHORTEN_PATH}${current_directory:$needed_length}"
                    lp_path+=$shortened_path
                    __lp_escape "$shortened_path"
                    lp_path_format+="${shortened_directory_format}${ret}"

                    is_shortening=0
                fi
            elif [[ $LP_PATH_METHOD == "truncate_chars_from_dir_right" ]] && \
                (( ${#LP_MARK_SHORTEN_PATH} + LP_PATH_CHARACTER_KEEP < ${#current_directory} )); then

                shortened_path="${current_directory:0:$LP_PATH_CHARACTER_KEEP}${LP_MARK_SHORTEN_PATH}"
                lp_path+=$shortened_path
                __lp_escape "$shortened_path"
                lp_path_format+="${shortened_directory_format}${ret}"
                shortened_path_length=$(( shortened_path_length - ${#current_directory} + ${#LP_MARK_SHORTEN_PATH} + LP_PATH_CHARACTER_KEEP ))
            elif [[ $LP_PATH_METHOD == "truncate_chars_from_dir_middle" ]] && \
                (( ${#LP_MARK_SHORTEN_PATH} + LP_PATH_CHARACTER_KEEP * 2 < ${#current_directory} )); then

                shortened_path="${current_directory:0:$LP_PATH_CHARACTER_KEEP}${LP_MARK_SHORTEN_PATH}${current_directory: -$LP_PATH_CHARACTER_KEEP}"
                lp_path+=$shortened_path
                __lp_escape "$shortened_path"
                lp_path_format+="${shortened_directory_format}${ret}"
                shortened_path_length=$(( shortened_path_length - ${#current_directory} + ${#LP_MARK_SHORTEN_PATH} + LP_PATH_CHARACTER_KEEP * 2 ))
            else
                # Need to shorten, but no method matched, or the matched method
                # did not make the string any shorter.
                lp_path+=$current_directory
                __lp_escape "$current_directory"
                lp_path_format+="${path_format}${ret}"
            fi
        else
            __lp_end_path_left_shortening
            lp_path+=$current_directory
            __lp_escape "$current_directory"
            lp_path_format+="${path_format}${ret}"
        fi

        if [[ -n $path_to_proccess && ( $current_path != "/" || $separator != "/" ) ]] && (( ! is_shortening )); then
            if [[ $current_path != "/" ]]; then
                lp_path+="/"
            fi
            lp_path_format+="${separator_format}${separator}"
        fi
    done
}

###############
# Environment #
###############

# If we are connected with a X11 support
_lp_connected_display() {
    (( LP_ENABLE_DISPLAY )) || return 2

    [[ -n "${DISPLAY-}" ]]
}

_lp_connection() {
    if [[ -n "${SSH_CLIENT-}${SSH2_CLIENT-}${SSH_TTY-}" ]]; then
        lp_connection=ssh
        return
    elif [[ -n ${REMOTEHOST-} ]]; then
        lp_connection=tel  # Telnet
        return
    fi

    local sess_parent="$(ps -o comm= -p "$PPID" 2> /dev/null)"
    if [[ "$sess_parent" = "su" || "$sess_parent" = "sudo" ]]; then
        lp_connection=su   # su/sudo
    else
        lp_connection=lcl  # Local
    fi
}

_lp_chroot() {
    (( LP_ENABLE_CHROOT )) || return 2

    if [[ -r /etc/debian_chroot ]]; then
        IFS= read -r lp_chroot </etc/debian_chroot
        if [[ -n "$lp_chroot" ]]; then
            local ret
            __lp_escape "$lp_chroot"
            lp_chroot=$ret
            return 0
        fi
    fi
    return 1
}

_lp_error() {
    (( LP_ENABLE_ERROR )) || return 2

    (( lp_error != 0 ))
}

_lp_error_color() {
    _lp_error || return "$?"

    lp_error_color="${LP_COLOR_ERR}${lp_error}${NO_COL}"
}

_lp_multiplexer() {
    if [[ -n ${TMUX-} ]]; then
        lp_multiplexer=tmux
        return 0
    elif [[ "${TERM-}" == screen* ]]; then
        lp_multiplexer=screen
        return 0
    fi
    return 1
}

_lp_http_proxy() {
    (( LP_ENABLE_PROXY )) || return 2

    if [[ -n "${http_proxy-}${HTTP_PROXY-}${https_proxy-}${HTTPS_PROXY-}${all_proxy-}${ALL_PROXY-}" ]]; then
        local ret
        __lp_escape "${http_proxy:-${HTTP_PROXY:-${https_proxy:-${HTTPS_PROXY:-${all_proxy:-$ALL_PROXY}}}}}"
        lp_http_proxy=$ret
    else
        return 1
    fi
}

_lp_http_proxy_color() {
    _lp_http_proxy || return "$?"

    lp_http_proxy_color="${LP_COLOR_PROXY}${LP_MARK_PROXY}${NO_COL}"
}

# Determine what type of user we are
_lp_user() {
    if (( EUID == 0 )); then
        # user is root
        return 2
    elif [[ "${USER-}" != "$(logname 2>/dev/null || printf '%s' "${LOGNAME-}")" ]]; then
        # user is not login user
        return 1
    else
        return 0
    fi
}

# Return the username (if we should display one).
_lp_username() {
    if (( LP_USER_ALWAYS == -1 )); then
        # No username ever
        return 2
    elif (( LP_USER_ALWAYS )) || ! _lp_user; then
        lp_username=${USER:-${USERNAME:-${LOGNAME-}}}

        if [[ -z $lp_username ]]; then
            lp_username=$(id -nu 2>/dev/null)
        fi

        local ret
        __lp_escape "$lp_username"
        lp_username=$ret

        return 0
    else
        return 1
    fi
}

_lp_username_color() {
    _lp_username || return "$?"

    lp_username_color="${LP_COLOR_USER}${lp_username}${NO_COL}"
}

# Test the code with the commands:
#   sudo id   # sudo, enter your credentials
#   sudo -K   # revoke your credentials
#   sudo -v   # return non-zero when no credentials are cached
#   sudo -nvk # return true if user can run commands without password input
_lp_sudo_active() {
    (( LP_ENABLE_SUDO )) || return 2
    \sudo -nv 2>/dev/null || return 1
}

_lp_sudo_active_color() {
    (( LP_ENABLE_SUDO )) || return 2

    if _lp_sudo_active; then
        lp_sudo_active_color=$LP_COLOR_MARK_SUDO
    else
        lp_sudo_active_color=$LP_COLOR_MARK_NO_SUDO
    fi
}

_lp_hostname() {
    # Only process hostname elements if we haven't turned them off
    if (( LP_HOSTNAME_ALWAYS != -1 )); then
        _lp_connection
        if [[ $lp_connection == lcl ]] && ! (( LP_HOSTNAME_ALWAYS )); then
            # no hostname if local
            return 1
        fi

        if [[ $LP_HOSTNAME_METHOD == fqdn ]]; then
            lp_hostname=$(hostname -f 2>/dev/null)
        elif [[ $LP_HOSTNAME_METHOD == pretty ]]; then
            lp_hostname=$(hostnamectl --pretty 2>/dev/null)
        fi

        if [[ -z ${lp_hostname-} ]]; then
            lp_hostname=${HOSTNAME:-${HOST-}}
        fi

        # Truncate to the first subdomain
        if [[ $LP_HOSTNAME_METHOD == short ]]; then
            lp_hostname=${lp_hostname%%.*}
        fi

        local ret
        __lp_escape "$lp_hostname"
        lp_hostname=$ret
    else
        return 2
    fi
}

# Put the hostname if not locally connected
# color it in cyan within SSH, and a warning red if within telnet
# else display the host without color
_lp_hostname_color() {
    if _lp_connected_display; then
        lp_hostname_color="${LP_COLOR_X11_ON}"
    else
        lp_hostname_color="${LP_COLOR_X11_OFF}"
    fi

    if _lp_chroot; then
        lp_hostname_color+="(${lp_chroot})"
    fi

    if _lp_hostname; then
        case "$lp_connection" in
            lcl)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_HOST}${lp_hostname}${NO_COL}"
                ;;
            ssh)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_SSH}${lp_hostname}${NO_COL}"
                ;;
            su)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_SU}${lp_hostname}${NO_COL}"
                ;;
            tel)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_TELNET}${lp_hostname}${NO_COL}"
                ;;
            *)
                lp_hostname_color+="${LP_MARK_X11}${NO_COL}${lp_hostname}" # defaults to no color
                ;;
        esac
    else
        if [[ -n ${lp_chroot-} ]]; then
            # End the color of the chroot
            lp_hostname_color+=${NO_COL}
        else
            # Nothing to display
            lp_hostname_color=""
            return 1
        fi
    fi
}

_lp_dirstack() {
    (( LP_ENABLE_DIRSTACK )) || return 2

    local count dir_stack
    dir_stack=$(dirs -p; printf x)

    __lp_line_count "${dir_stack%x}"
    lp_dirstack=$count

    (( lp_dirstack > 1 ))
}

_lp_dirstack_color() {
    _lp_dirstack || return "$?"

    lp_dirstack_color="${LP_COLOR_DIRSTACK}${LP_MARK_DIRSTACK}${lp_dirstack}${NO_COL}"
}

_lp_shell_level() {
    (( LP_ENABLE_SHLVL )) || return 2

    lp_shell_level=${SHLVL:-1}

    (( lp_shell_level >= LP_SHLVL_THRESHOLD ))
}

_lp_shell_level_color() {
    _lp_shell_level || return "$?"

    lp_shell_level_color="${LP_COLOR_SHLVL}${LP_MARK_SHLVL}${lp_shell_level}${NO_COL}"
}

################
# Related jobs #
################

# Return the count of detached screen and/or tmux sessions.
_lp_detached_sessions() {
    (( LP_ENABLE_DETACHED_SESSIONS )) || return 2

    local -i count=0
    (( _LP_ENABLE_SCREEN )) && count=$(screen -ls 2> /dev/null | GREP_OPTIONS='' \grep -c '[Dd]etach[^)]*)$')
    (( _LP_ENABLE_TMUX )) && count+=$(tmux list-sessions 2> /dev/null | GREP_OPTIONS='' \grep -cv 'attached')
    lp_detached_sessions=$count

    (( lp_detached_sessions ))
}

# Return the count of attached running shell jobs (started with $ myjob &) and/or
# stopped jobs (suspended with Ctrl-Z).
_lp_jobcount() {
    (( LP_ENABLE_JOBS )) || return 2

    local jobs
    local -i count
    # Count running jobs
    # The $(...) syntax strips trailing newlines, so add a character to the end
    # then remove it to prevent that. Otherwise 0 and 1 jobs look the same.
    jobs="$(jobs -r; printf x)"
    __lp_line_count "${jobs%x}"
    lp_running_jobs=$count

    # Count stopped jobs
    jobs="$(jobs -s; printf x)"
    __lp_line_count "${jobs%x}"
    lp_stopped_jobs=$count

    (( lp_running_jobs || lp_stopped_jobs ))
}

# Display the count of detached sessions and shell jobs if not zero.
_lp_jobcount_color() {
    (( LP_ENABLE_JOBS || LP_ENABLE_DETACHED_SESSIONS )) || return 2

    lp_jobcount_color=

    _lp_detached_sessions && lp_jobcount_color="${LP_COLOR_JOB_D}${lp_detached_sessions}d${NO_COL}"

    if _lp_jobcount; then
        if (( lp_running_jobs > 0 )); then
            [[ -n "$lp_jobcount_color" ]] && lp_jobcount_color+="$LP_MARK_JOBS_SEPARATOR"
            lp_jobcount_color+="${LP_COLOR_JOB_R}${lp_running_jobs}&${NO_COL}"
        fi
        if (( lp_stopped_jobs > 0 )); then
            [[ -n "$lp_jobcount_color" ]] && lp_jobcount_color+="$LP_MARK_JOBS_SEPARATOR"
            lp_jobcount_color+="${LP_COLOR_JOB_Z}${lp_stopped_jobs}z${NO_COL}"
        fi
    fi

    [[ -n "$lp_jobcount_color" ]]
}

####################
# Git info display #
####################

_lp_is_git_enabled() {
    local _path
    for _path in ${LP_DISABLED_GIT_PATHS[@]+"${LP_DISABLED_GIT_PATHS[@]}"}; do
        if [[ -n "$_path" && "$PWD" == "$_path"* ]]; then
            return 1
        fi
    done
    return 0
}

_lp_find_git() {
    if _lp_git_active; then
        if _lp_is_git_enabled; then
            lp_git_dir="$(\git rev-parse --git-dir 2>/dev/null)"
            lp_git_root="$(\git rev-parse --show-toplevel 2>/dev/null)"

            if [[ -n "${VCSH_DIRECTORY-}" ]]; then
                lp_git_type="vcsh"
            elif [[ -d "${lp_git_dir}/svn" ]]; then
                lp_git_type="svn"
            else
                lp_git_type="git"
            fi
        else
            lp_git_dir=""
            lp_git_root=""
            lp_git_type="disabled"

            return 2
        fi
    else
        lp_git_dir=""
        lp_git_root=""
        lp_git_type=""

        return 1
    fi
}

# Set the prompt mark.
_lp_smart_mark() {
    case "${1:-$lp_git_type}" in
        git)      lp_smart_mark="$LP_MARK_GIT";;
        svn)      lp_smart_mark="$LP_MARK_GIT$LP_MARK_SVN";;
        vcsh)     lp_smart_mark="$LP_MARK_VCSH${VCSH_DIRECTORY-}$LP_MARK_GIT$LP_MARK_VCSH";;
        disabled) lp_smart_mark="$LP_MARK_DISABLED";;
        *)        lp_smart_mark="$LP_MARK_DEFAULT";;
    esac
}

# Create a formatted string describing the status of the repo.
_lp_git_details_color() {
    lp_git_details_color=""

    if _lp_git_has_stash; then
        lp_git_details_color+="${LP_COLOR_GIT_STASH}${LP_MARK_GIT_STASH}${NO_COL} "
    fi

    _lp_git_status
    if $lp_git_has_untracked_files; then
        lp_git_details_color+="${LP_COLOR_GIT_UNTRACKED}${LP_MARK_GIT_UNTRACKED}${NO_COL} "
    fi
    if $lp_git_has_modifications; then
        lp_git_details_color+="${LP_COLOR_GIT_MODIFICATIONS}${LP_MARK_GIT_MODIFICATIONS}${NO_COL} "
    fi
    if $lp_git_has_deletions; then
        lp_git_details_color+="${LP_COLOR_GIT_DELETIONS}${LP_MARK_GIT_DELETIONS}${NO_COL} "
    fi
    if $lp_git_has_adds; then
        lp_git_details_color+="${LP_COLOR_GIT_ADDS}${LP_MARK_GIT_ADDS}${NO_COL} "
    fi
    if $lp_git_has_modifications_cached; then
        lp_git_details_color+="${LP_COLOR_GIT_CACHED_MODIFICATIONS}${LP_MARK_GIT_CACHED_MODIFICATIONS}${NO_COL} "
    fi
    if $lp_git_has_deletions_cached; then
        lp_git_details_color+="${LP_COLOR_GIT_CACHED_DELETIONS}${LP_MARK_GIT_CACHED_DELETIONS}${NO_COL} "
    fi
    if $lp_git_ready_to_commit; then
        lp_git_details_color+="${LP_COLOR_GIT_COMMIT}${LP_MARK_GIT_COMMIT}${NO_COL} "
    fi

    if _lp_git_head_status; then
        lp_git_details_color+="${LP_COLOR_GIT_HEAD_STATUS}${LP_MARK_GIT_HEAD_STATUS} ${lp_git_head_status}"
        if [[ -n "${lp_git_head_details-}" ]]; then
            lp_git_details_color+=" (${lp_git_head_details})"
        fi
        lp_git_details_color+="${NO_COL} "
    fi

    if [[ -n $lp_git_details_color ]]; then
        lp_git_details_color+="| "
    fi

    if _lp_git_branch; then
        if [[ -n "$lp_git_remote" ]]; then
            if [[ "$lp_git_commit_behind" -gt 0 && "$lp_git_commit_ahead" -gt 0 ]]; then
                lp_git_details_color+="${LP_COLOR_GIT_COMMITS}-${lp_git_commit_behind}${NO_COL} "
                lp_git_details_color+="${LP_COLOR_GIT_DIVERGED}${LP_MARK_GIT_DIVERGED}${NO_COL} "
                lp_git_details_color+="${LP_COLOR_GIT_COMMITS}+${lp_git_commit_ahead}${NO_COL} "
            elif [[ "$lp_git_commit_behind" -gt 0 ]]; then
                lp_git_details_color+="${LP_COLOR_GIT_COMMITS}-${lp_git_commit_behind}${NO_COL} "
                lp_git_details_color+="${LP_COLOR_GIT_FAST_FORWARD}${LP_MARK_GIT_FAST_FORWARD}${NO_COL} "
            elif [[ "$lp_git_commit_ahead" -gt 0 ]]; then
                lp_git_details_color+="${LP_COLOR_GIT_PUSH}${LP_MARK_GIT_PUSH}${NO_COL} "
                lp_git_details_color+="${LP_COLOR_GIT_COMMITS}+${lp_git_commit_ahead}${NO_COL} "
            fi

            lp_git_details_color+="(${LP_COLOR_GIT_LOCAL}${lp_git_branch}${NO_COL}"
            if [[ "$lp_git_pull_type" == "rebase" ]]; then
                lp_git_details_color+=" ${LP_MARK_GIT_REBASE} "
            else
                lp_git_details_color+=" ${LP_MARK_GIT_MERGE} "
            fi
            lp_git_details_color+="${LP_COLOR_GIT_UPSTREAM}${lp_git_remote}${NO_COL})"
        else
            lp_git_details_color+="${LP_COLOR_GIT_LOCAL}(${lp_git_branch})${NO_COL}"
        fi
    else
        lp_git_details_color+="${LP_COLOR_GIT_DETACHED}(${NO_COL}"
        lp_git_details_color+="${LP_COLOR_GIT_MARK_DETACHED}${LP_MARK_GIT_DETACHED}${NO_COL}"
        lp_git_details_color+="${LP_COLOR_GIT_DETACHED}${lp_git_commit_id})${NO_COL}"
    fi

    if _lp_git_tag; then
        lp_git_details_color+=" ${LP_COLOR_GIT_TAG}${LP_MARK_GIT_TAG} $lp_git_tag${NO_COL}"
    fi
}

_lp_git_active() {
    (( LP_ENABLE_GIT )) || return 2
    \git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 1
}

_lp_git_has_stash() {
    \git rev-parse --verify -q refs/stash >/dev/null || return 1
}

_lp_git_status() {
    local git_status="$(LC_ALL=C \git status --porcelain 2>/dev/null)"

    if [[ $git_status =~ ($'\n'|^)[?] ]]; then
        lp_git_has_untracked_files=true
    else
        lp_git_has_untracked_files=false
    fi

    if [[ $git_status =~ ($'\n'|^).M ]]; then
        lp_git_has_modifications=true
    else
        lp_git_has_modifications=false
    fi

    if [[ $git_status =~ ($'\n'|^)M ]]; then
        lp_git_has_modifications_cached=true
    else
        lp_git_has_modifications_cached=false
    fi

    if [[ $git_status =~ ($'\n'|^)A ]]; then
        lp_git_has_adds=true
    else
        lp_git_has_adds=false
    fi

    if [[ $git_status =~ ($'\n'|^).D ]]; then
        lp_git_has_deletions=true
    else
        lp_git_has_deletions=false
    fi

    if [[ $git_status =~ ($'\n'|^)D ]]; then
        lp_git_has_deletions_cached=true
    else
        lp_git_has_deletions_cached=false
    fi

    if [[ $git_status =~ ($'\n'|^)[MAD] && ! $git_status =~ ($'\n'|^).[MAD?] ]]; then
        lp_git_ready_to_commit=true
    else
        lp_git_ready_to_commit=false
    fi
}

_lp_git_head_status() {
    local IFS="" step total

    if [[ -f "${lp_git_dir}/MERGE_HEAD" ]]; then
        lp_git_head_status="merge"
    elif [[ -d "${lp_git_dir}/rebase-merge" ]]; then
        test -r "${lp_git_dir}/rebase-merge/msgnum" && read -r step <"${lp_git_dir}/rebase-merge/msgnum"
        test -r "${lp_git_dir}/rebase-merge/end" && read -r total <"${lp_git_dir}/rebase-merge/end"
        if [[ -f "${lp_git_dir}/rebase-merge/interactive" ]]; then
            lp_git_head_status="rebase -i"
        else
            lp_git_head_status="rebase -m"
        fi
    elif [[ -d "${lp_git_dir}/rebase-apply" ]]; then
        test -r "${lp_git_dir}/rebase-apply/next" && read -r step <"${lp_git_dir}/rebase-apply/next"
        test -r "${lp_git_dir}/rebase-apply/last" && read -r total <"${lp_git_dir}/rebase-apply/last"
        if [[ -f "${lp_git_dir}/rebase-apply/rebasing" ]]; then
            lp_git_head_status="rebase"
        elif [[ -f "${lp_git_dir}/rebase-apply/applying" ]]; then
            lp_git_head_status="am"
        else
            lp_git_head_status="am/rebase"
        fi
    elif [[ -f "${lp_git_dir}/CHERRY_PICK_HEAD" ]]; then
        lp_git_head_status="cherry-pick"
    elif [[ -f "${lp_git_dir}/REVERT_HEAD" ]]; then
        lp_git_head_status="revert"
    elif [[ -f "${lp_git_dir}/BISECT_START" ]]; then
        lp_git_head_status="bisect"
    else
        return 1
    fi

    if [[ -n "$step" && -n "$total" ]]; then
        lp_git_head_details="${step}/${total}"
    else
        lp_git_head_details=""
    fi
}

_lp_git_tag() {
    lp_git_tag=""

    local tag ret

    if tag="$(\git describe --tags --exact-match 2>/dev/null)"; then
        __lp_escape "$tag"
        lp_git_tag="$ret"
    else
        return 1
    fi
}

_lp_git_branch() {
    lp_git_branch=""
    lp_git_remote=""
    lp_git_commit_id=""
    lp_git_commit_ahead=0
    lp_git_commit_behind=0
    lp_git_pull_type="merge"

    local branch remote pull_rebase counts ret

    if branch="$(\git symbolic-ref --short -q HEAD 2>/dev/null)"; then
        __lp_escape "$branch"
        lp_git_branch="$ret"

        if remote="$(\git rev-parse --symbolic-full-name --abbrev-ref @{upstream} 2>/dev/null)"; then
            __lp_escape "${remote//\/$branch/}"
            lp_git_remote="$ret"

            pull_rebase=$(\git config --get branch.${branch}.rebase 2>/dev/null)
            [[ -z "$pull_rebase" ]] && pull_rebase=$(\git config --get pull.rebase 2>/dev/null)
            if [[ -n "$pull_rebase" && "$pull_rebase" != "false" ]]; then
                lp_git_pull_type="rebase"
            fi

            counts="$(\git rev-list --count --left-right 'HEAD...@{upstream}' 2>/dev/null)"
            IFS=$' \t' read -r lp_git_commit_ahead lp_git_commit_behind <<<"$counts"
        fi
    else
        lp_git_commit_id="$(\git rev-parse --short -q HEAD 2>/dev/null)"

        return 1
    fi
}

##########
# Title #
##########

_lp_formatted_title() {
    (( LP_ENABLE_TITLE )) || return 2

    # Get the input as pure text
    local ret
    __lp_strip_escapes "${1-}"
    _lp_generated_title="$ret"
}

lp_title() {
    (( LP_ENABLE_TITLE )) || return 2

    if [[ -n ${1+x} ]]; then
        _lp_manual_title=$1
    else
        unset _lp_manual_title
    fi
}

###################
# CURRENT TIME    #
###################

_lp_time() {
    (( LP_ENABLE_TIME )) || return 2

    local ret
    __lp_escape "$(date "+${LP_TIME_FORMAT}")"
    lp_time=$ret
}

_lp_time_color() {
    _lp_time || return "$?"

    lp_time_color="${LP_COLOR_TIME}${lp_time}${NO_COL}"
}

#################
# Default theme #
#################

_lp_default_theme_activate() {
    # Default value for LP_PERM when LP_ENABLE_PERM is 0
    LP_PERM=${LP_MARK_PERM}   # without color

    _lp_user
    local -i user_type="$?"

    if (( user_type < 2 )); then  # if user is not root
        if (( LP_ENABLE_SUDO )); then
            LP_COLOR_MARK_NO_SUDO="$LP_COLOR_MARK"
        fi
    else # root!
        if (( ! LP_ENABLE_GIT_ROOT )); then
            LP_MARK_DISABLED="$LP_MARK_DEFAULT"
        fi
    fi

    # The user or connection type is not expected to change from inside the
    # shell, so we build this just once.
    if _lp_username_color; then
        LP_USER="$lp_username_color"
    else
        LP_USER=
    fi

    _lp_hostname_color
    LP_HOST="$lp_hostname_color"

    # If we are running in a terminal multiplexer, brackets are colored
    if _lp_multiplexer; then
        LP_BRACKET_OPEN="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_OPEN}${NO_COL}"
        LP_BRACKET_CLOSE="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
    else
        LP_BRACKET_OPEN="${LP_COLOR_IN_LOCAL}${LP_MARK_BRACKET_OPEN}${NO_COL}"
        LP_BRACKET_CLOSE="${LP_COLOR_IN_LOCAL}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
    fi
}

_lp_default_theme_directory() {
    # LP_PERM: shows a ":"
    # - colored in green if user has write permission on the current dir
    # - colored in red if not
    # - can set another symbol with LP_MARK_PERM
    if (( LP_ENABLE_PERM )); then
        if [[ -w "${PWD}" ]]; then
            LP_PERM="${LP_COLOR_WRITE}${LP_MARK_PERM}${NO_COL}"
        else
            LP_PERM="${LP_COLOR_NOWRITE}${LP_MARK_PERM}${NO_COL}"
        fi
    fi

    local lp_path_format
    _lp_path_format "$LP_COLOR_PATH" "$LP_COLOR_PATH_LAST_DIR" "$LP_COLOR_PATH_GIT_ROOT" "$LP_COLOR_PATH_SHORTENED" "/" "$LP_COLOR_PATH_SEPARATOR"

    LP_PWD="${lp_path_format}${NO_COL}"
}

# Do not complain about unused variables.
_lp_default_theme_prompt_data() {
    # left of main prompt: space at right
    if _lp_jobcount_color; then
        LP_JOBS="$lp_jobcount_color "
    else
        LP_JOBS=
    fi

    if _lp_time_color; then
        LP_TIME="$lp_time_color "
    else
        LP_TIME=
    fi

    if _lp_sudo_active_color; then
        LP_COLOR_MARK="$lp_sudo_active_color"
    fi

    if _lp_dirstack_color; then
        LP_DIRSTACK=" $lp_dirstack_color"
    else
        LP_DIRSTACK=
    fi

    # in main prompt: no space
    if _lp_http_proxy_color; then
        LP_PROXY="$lp_http_proxy_color"
    else
        LP_PROXY=
    fi

    if _lp_shell_level_color; then
        LP_SHLVL="$lp_shell_level_color"
    else
        LP_SHLVL=
    fi

    if _lp_error_color; then
        LP_ERR=" $lp_error_color"
    else
        LP_ERR=
    fi

    if _lp_find_git && _lp_git_details_color; then
        LP_GIT=" $lp_git_details_color"
    else
        LP_GIT=
    fi

    _lp_smart_mark
    LP_MARK="${lp_smart_mark}${NO_COL} "
}

_lp_default_theme_prompt_template() {
    if [[ -f "${LP_PS1_FILE-}" ]]; then
        source "$LP_PS1_FILE"
    fi

    if [[ -z "${LP_PS1-}" ]]; then
        # Add title escape time and jobs.
        PS1="${LP_PS1_PREFIX}${LP_TIME}${LP_JOBS}"
        # Add multiplexer brackets, user, host and permissions colon.
        PS1+="${LP_BRACKET_OPEN}${LP_USER}${LP_HOST}${LP_PERM}"
        # Add working directory, dirstack, proxy and nested shell level.
        PS1+="${LP_PWD}${LP_DIRSTACK}${LP_BRACKET_CLOSE}${LP_PROXY}${LP_SHLVL}"

        # Add Git info
        # If root, the info has not been collected unless LP_ENABLE_GIT_ROOT
        # is set.
        PS1+="${LP_GIT}"

        # Add return code, prompt mark and user-defined postfix.
        PS1+="${LP_ERR}${LP_MARK_PREFIX}${LP_COLOR_MARK}${LP_MARK}${LP_PS1_POSTFIX}"

        # Get the core sections without prompt escapes and make them into a title.
        _lp_formatted_title "${LP_PS1_PREFIX}${LP_BRACKET_OPEN}${LP_USER}${LP_HOST}${LP_MARK_PERM}${LP_PWD}${LP_BRACKET_CLOSE} ${LP_MARK}${LP_PS1_POSTFIX}"
    else
        PS1=$LP_PS1
    fi
}

_lp_default_theme_prompt() {
    _lp_default_theme_prompt_data
    _lp_default_theme_prompt_template
}

########################
# Construct the prompt #
########################

__lp_set_prompt() {
    # Display the return value of the last command, if different from zero
    # As this get the last returned code, it should be called first
    local -i lp_error="$?"

    if (( LP_HIDE_EMPTY_ERROR )); then
        (( ! ${_LP_REAL_COMMAND:-1} )) && lp_error=0
        _LP_REAL_COMMAND=0
    fi

    # bash: execute the old prompt hook
    if [[ -n ${LP_OLD_PROMPT_COMMAND-} ]]; then
        eval "$LP_OLD_PROMPT_COMMAND"
    fi

    # if change of working directory
    if [[ "${LP_OLD_PWD-}" != "LP:$PWD" ]]; then
        _lp_default_theme_directory

        # Prefix with 'LP:' to prevent Zsh with AUTO_NAME_DIRS enabled using
        # this var as a name for the working directory, that will be used by
        # the '%' and related prompt sequences.
        # See https://github.com/liquidprompt/liquidprompt/issues/124 for details.
        LP_OLD_PWD="LP:$PWD"
    fi

    _lp_default_theme_prompt

    if (( LP_ENABLE_TITLE )); then
        PS1="${_LP_OPEN_ESC}${LP_TITLE_OPEN}${_lp_manual_title:-${_lp_generated_title-${SHELL-}}}${LP_TITLE_CLOSE}${_LP_CLOSE_ESC}${PS1}"
    fi
}

__lp_preexec() {
    if (( LP_HIDE_EMPTY_ERROR )); then
        _LP_REAL_COMMAND=1
    fi
}

__lp_before_command() {
    # If this is the last thing before prompt is being drawn, the command is done,
    # so mark the next trap. Note these two events could be at the same
    # time, so no elif is used.
    local first_command last_command
    first_command=$PROMPT_COMMAND
    if (( ${BASH_VERSINFO[0]:-0} > 5 || ( ${BASH_VERSINFO[0]:-0} == 5 && ${BASH_VERSINFO[1]:-0} >= 1 ) )); then
        last_command=${PROMPT_COMMAND[-1]}
    else
        last_command=$PROMPT_COMMAND
    fi

    if [[ "$last_command" == *"$BASH_COMMAND" ]]; then
        _LP_AT_PROMPT=1
        # Return early, because the PROMPT_COMMAND should never trigger preexec hooks.
        return
    fi

    # If this is the first time after the user submitted the command,
    # execute the hooks, unless the user submitted an empty command.
    if (( _LP_AT_PROMPT )); then
        _LP_AT_PROMPT=0
        if [[ "$first_command" != "$BASH_COMMAND"* ]]; then
            __lp_preexec
        fi
    fi
}

prompt_tag() {
    if [[ -n "${1-}" ]]; then
        export LP_PS1_PREFIX="$1 "
    else
        export LP_PS1_PREFIX=
    fi
}

# Activate Liquid Prompt
prompt_on() {
    # Reset so all PWD dependent variables are computed after loading
    LP_OLD_PWD=""

    # if Liquid Prompt has not been already set
    if [[ -z "${LP_OLD_PS1-}" ]]; then
        LP_OLD_PS1="$PS1"
    fi

    if (( _LP_SHELL_bash )); then
        # Prevent some cases where the user shoots in his own foot.
        # PROMPT_COMMAND is not exported by default, but some users
        # incorrectly export it from their profile/bashrc (GitHub #450),
        # so we preventively UNexport it.
        # TODO: warn the user if it was exported
        if (( ${BASH_VERSINFO[0]:-0} > 4 || ( ${BASH_VERSINFO[0]:-0} == 4 && ${BASH_VERSINFO[1]:-0} >= 2 ) )); then
            # -g is only available since bash 4.2
            declare -g +x PROMPT_COMMAND
        fi

        local set_prompt_command=__lp_set_prompt

        if (( ${BASH_VERSINFO[0]:-0} > 5 || ( ${BASH_VERSINFO[0]:-0} == 5 && ${BASH_VERSINFO[1]:-0} >= 1 ) )); then
            # PROMPT_COMMAND is an array since bash 5.1
            if ! ( __lp_array_contains __lp_set_prompt ${PROMPT_COMMAND[@]+"${PROMPT_COMMAND[@]}"} ); then
               PROMPT_COMMAND+=( "$set_prompt_command" )
            fi
        else
            if [[ -z ${LP_OLD_PROMPT_COMMAND+x} ]]; then
                LP_OLD_PROMPT_COMMAND="${PROMPT_COMMAND-}"
            fi
            PROMPT_COMMAND="$set_prompt_command"
        fi

        if (( ${_LP_ENABLE_PREEXEC-0} )); then
            _LP_AT_PROMPT=0
            # __lp_before_command gets called just before bash executes a command,
            # including $PROMPT_COMMAND
            # Pass $_ to this call, because it sets $_ to what it already was
            trap '__lp_before_command "$_"' DEBUG
        fi
    else # zsh
        if [[ -z ${_LP_OLD_SETOPT-} ]]; then
            # Dump option names: echo ${(ko)options}
            if [[ "${options[promptpercent]}" == on ]]; then
                _LP_OLD_SETOPT="promptpercent"
            else
                _LP_OLD_SETOPT="nopromptpercent"
            fi
        fi

        # Set options that affect PS1 evaluation; enable percent expansion
        setopt promptpercent

        add-zsh-hook precmd __lp_set_prompt

        if (( ${_LP_ENABLE_PREEXEC-0} )); then
            add-zsh-hook preexec __lp_preexec
        fi
    fi
}

# Disable previous hooks as options that set them may have changed
__lp_disable_hooks() {
    if (( _LP_SHELL_bash )); then
        if (( ${BASH_VERSINFO[0]:-0} > 5 || ( ${BASH_VERSINFO[0]:-0} == 5 && ${BASH_VERSINFO[1]:-0} >= 1 ) )); then
            # PROMPT_COMMAND is an array since bash 5.1
            for i in ${PROMPT_COMMAND[@]+"${!PROMPT_COMMAND[@]}"}; do
                local value="${PROMPT_COMMAND[i]}"
                if [[ $value == "__lp_set_prompt" ]]; then
                    unset 'PROMPT_COMMAND[i]'
                fi
            done
        else
            if [[ -n ${LP_OLD_PROMPT_COMMAND+x} ]]; then
                PROMPT_COMMAND="${LP_OLD_PROMPT_COMMAND-}"
                unset LP_OLD_PROMPT_COMMAND
            else
                unset PROMPT_COMMAND
            fi
        fi

        # Disable the DEBUG trap used by the HIDE_EMPTY_ERROR feature
        # TODO: Fix this: Bash will unset the function's DEBUG trap, not the global one.
        if (( ${_LP_ENABLE_PREEXEC-0} )); then
            trap - DEBUG
        fi
    else # zsh
        {
            add-zsh-hook -d precmd  __lp_set_prompt
            add-zsh-hook -d preexec __lp_preexec
        } >/dev/null
    fi
}

# Come back to the old prompt
prompt_off() {
    __lp_disable_hooks

    PS1=$LP_OLD_PS1

    if (( _LP_SHELL_zsh )); then
        setopt "${_LP_OLD_SETOPT}"
    fi
}

# Use an empty prompt: just the ❯ mark
prompt_OFF() {
    __lp_disable_hooks

    PS1="❯ "

    if (( _LP_SHELL_zsh )); then
        setopt "${_LP_OLD_SETOPT}"
    fi
}

# By default, sourcing 'liquidprompt' will activate Liquid Prompt
if [ "${1-}" != "--no-activate" ]; then
    lp_activate
fi

# vim: set ft=sh et sts=4 sw=4 tw=120:
