################################################################################
# LIQUID PROMPT
# An intelligent and non-intrusive prompt for Bash and zsh
################################################################################

# Licensed under the AGPL version 3
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Issue #161: do not load if not an interactive shell
test -z "$TERM" -o "x$TERM" = xdumb && return

if test -n "${BASH_VERSION-}"; then
    _LP_SHELL_bash=1
    _LP_SHELL_zsh=0
    _LP_OPEN_ESC="\["
    _LP_CLOSE_ESC="\]"

    _LP_USER_SYMBOL="\u"
    _LP_HOST_SYMBOL="\h"
    _LP_FQDN_SYMBOL="\H"
    _LP_TIME_SYMBOL="\t"
    _LP_MARK_SYMBOL='\$'
    _LP_PWD_SYMBOL="\\w"
    _LP_DIR_SYMBOL="\\W"

    _LP_PERCENT='%'    # must be escaped on zsh
    _LP_BACKSLASH='\\' # must be escaped on bash

    # Sed expression using extended regexp to match terminal
    # escape sequences with their wrappers
    _LP_CLEAN_ESC='\\\[([^\]+|\\[^]])*\\\]'

    # Escape the given strings
    # Must be used for all strings injected in PS1 that may comes from remote sources,
    # like $PWD, VCS branch names...
    __lp_escape() {
        ret="${1//\\/\\\\}"
    }
elif test -n "${ZSH_VERSION-}"; then
    _LP_SHELL_bash=0
    _LP_SHELL_zsh=1
    _LP_OPEN_ESC="%{"
    _LP_CLOSE_ESC="%}"

    _LP_USER_SYMBOL="%n"
    _LP_HOST_SYMBOL="%m"
    _LP_FQDN_SYMBOL="%M"
    _LP_TIME_SYMBOL="%*"
    _LP_MARK_SYMBOL='%(!.#.%%)'
    _LP_PWD_SYMBOL="%~"
    _LP_DIR_SYMBOL="%1~"

    _LP_PERCENT='%%'
    _LP_BACKSLASH="\\"

    _LP_CLEAN_ESC='%\{([^%]+|%[^}])*%\}'

    __lp_escape() {
        local arg="${1//\\/\\\\}"
        ret="${arg//\%/$_LP_PERCENT}"
    }
else
    echo "liquidprompt: shell not supported" >&2
    return
fi

#################
# CONFIGURATION #
#################

# The following code is run just once. But it is encapsulated in a function
# to benefit of 'local' variables.
#
# What we do here:
# 1. Setup variables that can be used by the user: the "API" of Liquid Prompt
#    for config/theme. Those variables are local to the function.
#    In practice, this is only color variables.
# 2. Setup default values
# 3. Load the configuration
__lp_source_config() {
    local af_color= ab_color=

    # Colors: variables are local so they will have a value only
    # during config loading and will not conflict with other values
    # with the same names defined by the user outside the config.
    local BOLD="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${_LP_CLOSE_ESC}"

    # Foreground colors
    __lp_foreground_color 0
    local BLACK="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GRAY="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 1
    local RED="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_RED="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"
    __lp_foreground_color 0
    __lp_background_color 1
    local WARN_RED="${_LP_OPEN_ESC}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    __lp_foreground_color 7
    local CRIT_RED="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    __lp_foreground_color 3
    local DANGER_RED="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${ab_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 2
    local GREEN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GREEN="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 3
    local YELLOW="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_YELLOW="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 4
    local BLUE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_BLUE="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 5
    local PURPLE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local MAGENTA="${PURPLE}"
    local PINK="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_PURPLE="${PINK}"
    local BOLD_MAGENTA="${PINK}"

    __lp_foreground_color 6
    local CYAN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_CYAN="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    __lp_foreground_color 7
    local WHITE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_WHITE="${_LP_OPEN_ESC}${_LP_TI_BOLD-}${af_color}${_LP_CLOSE_ESC}"

    # NO_COL is special: it will be used at runtime, not just during config loading
    NO_COL="${_LP_OPEN_ESC}${_LP_TI_RESET-}${_LP_CLOSE_ESC}"

    local configfile

    # System config
    configfile="/etc/xdg/liquidprompt/liquidpromptrc"
    [[ -f "$configfile" ]] && source "$configfile"

    # Local config
    configfile="${XDG_CONFIG_HOME:-"$HOME/.config"}/liquidprompt/liquidpromptrc"
    [[ -f "$configfile" ]] && source "$configfile"

    # Default values (globals)
    LP_PATH_LENGTH=${LP_PATH_LENGTH:-35}
    LP_PATH_KEEP=${LP_PATH_KEEP:-2}
    LP_HOSTNAME_ALWAYS=${LP_HOSTNAME_ALWAYS:-0}
    LP_USER_ALWAYS=${LP_USER_ALWAYS:-1}
    LP_PS1=${LP_PS1-""}
    LP_TAG=${LP_TAG-""}

    LP_ENABLE_PERM=${LP_ENABLE_PERM:-1}
    LP_ENABLE_SHORTEN_PATH=${LP_ENABLE_SHORTEN_PATH:-1}
    LP_ENABLE_PROXY=${LP_ENABLE_PROXY:-1}
    LP_ENABLE_JOBS=${LP_ENABLE_JOBS:-0}
    LP_ENABLE_GIT=${LP_ENABLE_GIT:-1}
    LP_ENABLE_OHMYGIT=${LP_ENABLE_OHMYGIT:-0}
    LP_ENABLE_HG=${LP_ENABLE_HG:-1}
    LP_ENABLE_TIME=${LP_ENABLE_TIME:-0}
    LP_ENABLE_VIRTUALENV=${LP_ENABLE_VIRTUALENV:-1}
    LP_ENABLE_SCLS=${LP_ENABLE_SCLS:-1}
    LP_ENABLE_VCS_ROOT=${LP_ENABLE_VCS_ROOT:-0}
    LP_ENABLE_TITLE=${LP_ENABLE_TITLE:-0}
    LP_ENABLE_SCREEN_TITLE=${LP_ENABLE_SCREEN_TITLE:-0}
    LP_ENABLE_FQDN=${LP_ENABLE_FQDN:-0}
    LP_ENABLE_SUDO=${LP_ENABLE_SUDO:-0}
    LP_ENABLE_ERR=${LP_ENABLE_ERR:-0}
    LP_ENABLE_COLOR=${LP_ENABLE_COLOR:-1}
    LP_DISABLED_VCS_PATHS=("${LP_DISABLED_VCS_PATHS[@]-}")

    LP_MARK_DEFAULT="${LP_MARK_DEFAULT:-$_LP_MARK_SYMBOL}"
    LP_MARK_PROXY="${LP_MARK_PROXY:-"↥"}"
    LP_MARK_HG="${LP_MARK_HG:-"☿"}"
    LP_MARK_SVN="${LP_MARK_SVN:-"‡"}"
    LP_MARK_GIT="${LP_MARK_GIT:-"±"}"
    LP_MARK_VCSH="${LP_MARK_VCSH:-"|"}"
    LP_MARK_DISABLED="${LP_MARK_DISABLED:-"⌀"}"
    LP_MARK_UNTRACKED="${LP_MARK_UNTRACKED:-"*"}"
    LP_MARK_STASH="${LP_MARK_STASH:-"+"}"
    LP_MARK_BRACKET_OPEN="${LP_MARK_BRACKET_OPEN:-"["}"
    LP_MARK_BRACKET_CLOSE="${LP_MARK_BRACKET_CLOSE:-"]"}"
    LP_MARK_SHORTEN_PATH="${LP_MARK_SHORTEN_PATH:-" … "}"
    LP_MARK_PERM="${LP_MARK_PERM:-":"}"
    LP_MARK_PREFIX="${LP_MARK_PREFIX-" "}"
    LP_MARK_SPACE="${LP_MARK_SPACE:-" "}"
    LP_MARK_VCS_OPEN="${LP_MARK_VCS_OPEN:-"("}"
    LP_MARK_VCS_CLOSE="${LP_MARK_VCS_CLOSE:-")"}"
    LP_MARK_X11="${LP_MARK_X11:-"@"}"

    LP_COLOR_PATH=${LP_COLOR_PATH:-$BOLD}
    LP_COLOR_PATH_ROOT=${LP_COLOR_PATH_ROOT:-$BOLD_YELLOW}
    LP_COLOR_PROXY=${LP_COLOR_PROXY:-$BOLD_BLUE}
    LP_COLOR_JOB_D=${LP_COLOR_JOB_D:-$YELLOW}
    LP_COLOR_JOB_R=${LP_COLOR_JOB_R:-$BOLD_YELLOW}
    LP_COLOR_JOB_Z=${LP_COLOR_JOB_Z:-$BOLD_YELLOW}
    LP_COLOR_ERR=${LP_COLOR_ERR:-$PURPLE}
    LP_COLOR_MARK=${LP_COLOR_MARK:-$BOLD}
    LP_COLOR_MARK_ROOT=${LP_COLOR_MARK_ROOT:-$BOLD_RED}
    LP_COLOR_MARK_SUDO=${LP_COLOR_MARK_SUDO:-$LP_COLOR_MARK_ROOT}
    LP_COLOR_USER_LOGGED=${LP_COLOR_USER_LOGGED:-""}
    LP_COLOR_USER_ALT=${LP_COLOR_USER_ALT:-$BOLD}
    LP_COLOR_USER_ROOT=${LP_COLOR_USER_ROOT:-$BOLD_YELLOW}
    LP_COLOR_HOST=${LP_COLOR_HOST:-""}
    LP_COLOR_SSH=${LP_COLOR_SSH:-$BLUE}
    LP_COLOR_SU=${LP_COLOR_SU:-$BOLD_YELLOW}
    LP_COLOR_TELNET=${LP_COLOR_TELNET:-$WARN_RED}
    LP_COLOR_X11_ON=${LP_COLOR_X11_ON:-$GREEN}
    LP_COLOR_X11_OFF=${LP_COLOR_X11_OFF:-$YELLOW}
    LP_COLOR_WRITE=${LP_COLOR_WRITE:-$GREEN}
    LP_COLOR_NOWRITE=${LP_COLOR_NOWRITE:-$RED}
    LP_COLOR_UP=${LP_COLOR_UP:-$GREEN}
    LP_COLOR_COMMITS=${LP_COLOR_COMMITS:-$YELLOW}
    LP_COLOR_COMMITS_BEHIND=${LP_COLOR_COMMITS_BEHIND:-$BOLD_RED}
    LP_COLOR_CHANGES=${LP_COLOR_CHANGES:-$RED}
    LP_COLOR_DIFF=${LP_COLOR_DIFF:-$PURPLE}
    LP_COLOR_TIME=${LP_COLOR_TIME:-$BLUE}
    LP_COLOR_IN_MULTIPLEXER=${LP_COLOR_IN_MULTIPLEXER:-$BOLD_BLUE}
    LP_COLOR_IN_LOCAL=${LP_COLOR_IN_LOCAL:-$WHITE}
    LP_COLOR_VIRTUALENV=${LP_COLOR_VIRTUALENV:-$CYAN}
}

lp_activate() {
    if (( _LP_SHELL_bash )); then
        complete -F __lp_theme_bash_complete lp_theme
    else # zsh
        # For ZSH, autoload required functions
        autoload -Uz add-zsh-hook

        # Disable previous hooks as options that set them
        # may have changed
        {
            add-zsh-hook -d precmd  __lp_set_prompt
        } >/dev/null

        autoload -Uz compinit && compinit && compdef __lp_theme_zsh_complete lp_theme
    fi

    # TermInfo feature detection
    _lp_af_colors=() _lp_ab_colors=()

    __lp_foreground_color() { return 2 ; }
    __lp_background_color() { return 2 ; }

    # TODO handle this case better. With no colors, no need for any escaping
    if ! command -v tput >/dev/null; then
        echo "liquidprompt: 'tput' not available; will not be able to format terminal" >&2
        LP_ENABLE_COLOR=0
    else
        _LP_TI_RESET="$( { tput sgr0 || tput me ; } 2>/dev/null )"
        _LP_TI_BOLD="$( { tput bold || tput md ; } 2>/dev/null )"
        _LP_TI_UNDERLINE="$( { tput smul || tput us ; } 2>/dev/null )"
        _LP_TI_COLORS="$( tput colors 2>/dev/null )"
        _LP_TI_COLORS=${_LP_TI_COLORS:-8}

        if tput setaf 0 >/dev/null 2>&1; then
            __lp_foreground_color() { af_color="${_lp_af_colors[$1+1]:=$(tput setaf "$1")}"; }
        elif tput AF 0 >/dev/null 2>&1; then
            # FreeBSD
            __lp_foreground_color() { af_color="${_lp_af_colors[$1+1]:=$(tput AF "$1")}"; }
        elif tput AF 0 0 0 >/dev/null 2>&1; then
            # OpenBSD
            __lp_foreground_color() { af_color="${_lp_af_colors[$1+1]:=$(tput AF "$1" 0 0)}"; }
        else
            echo "liquidprompt: terminal $TERM does not support foreground colors" >&2
        fi
        if tput setab 0 >/dev/null 2>&1; then
            __lp_background_color() { ab_color="${_lp_ab_colors[$1+1]:=$(tput setab "$1")}"; }
        elif tput AB 0 >/dev/null 2>&1; then
            # FreeBSD
            __lp_background_color() { ab_color="${_lp_ab_colors[$1+1]:=$(tput AB "$1")}"; }
        elif tput AB 0 0 0 >/dev/null 2>&1; then
            # OpenBSD
            __lp_background_color() { ab_color="${_lp_ab_colors[$1+1]:=$(tput AB "$1" 0 0)}"; }
        else
            echo "liquidprompt: terminal $TERM does not support background colors" >&2
        fi
    fi

    __lp_source_config

    # Disable feature if the tool is not installed
    _lp_require_tool()
    {
        (( LP_ENABLE_$1 )) && { command -v "$2" >/dev/null || eval LP_ENABLE_$1=0 ; }
    }

    _lp_require_tool GIT git
    _lp_require_tool HG hg

    _LP_ENABLED_VCSS=()
    (( LP_ENABLE_GIT )) && _LP_ENABLED_VCSS+=(git)
    (( LP_ENABLE_HG )) && _LP_ENABLED_VCSS+=(hg)

    unset -f _lp_require_tool

    command -v screen >/dev/null ; _LP_ENABLE_SCREEN=$(( ! $? ))
    command -v tmux >/dev/null   ; _LP_ENABLE_TMUX=$(( ! $? ))

    # Use standard path symbols inside Midnight Commander
    [[ -n "${MC_SID-}" ]] && LP_ENABLE_SHORTEN_PATH=0

    # If we are running in a terminal multiplexer, special title escapes
    if _lp_multiplexer; then
        (( LP_ENABLE_TITLE = LP_ENABLE_TITLE && LP_ENABLE_SCREEN_TITLE ))
        LP_TITLE_OPEN="$(printf '\033k')"
        # "\e\" but on bash \ must be escaped
        LP_TITLE_CLOSE="$(printf '\033%s' "$_LP_BACKSLASH")"
    else
        LP_TITLE_OPEN="$(printf '\e]0;')"
        LP_TITLE_CLOSE="$(printf '\a')"
    fi

    ###############
    # Who are we? #
    ###############

    _lp_user
    local -i user=$?

    if (( user < 2 )); then  # if user is not root
        if (( LP_ENABLE_SUDO )); then
            command -v sudo >/dev/null || LP_ENABLE_SUDO=0
        fi
    else # root!
        LP_ENABLE_SUDO=0
        if (( ! LP_ENABLE_VCS_ROOT )); then
            LP_DISABLED_VCS_PATHS=("/")
        fi
    fi

    #################
    # Where are we? #
    #################

    if (( LP_ENABLE_SHORTEN_PATH )); then
        if (( LP_PATH_KEEP == -1 )); then
            lp_path=$_LP_DIR_SYMBOL
            __lp_path() { : ; }
        else
            __lp_path() {
                local lp_shorten_path
                __lp_shorten_path
                lp_path=$lp_shorten_path
            }
        fi
    else
        # Will never change
        lp_path=$_LP_PWD_SYMBOL

        if (( _LP_SHELL_bash )) && [[ -n ${PROMPT_DIRTRIM-} ]]; then
            __lp_path() {
                __lp_set_dirtrim
            }
        else
            __lp_path() { : ; }
        fi
    fi

    if [[ -n ${_LP_THEME_ACTIVATE_FUNCTION-} ]]; then
        # Reactivate current theme
        "$_LP_THEME_ACTIVATE_FUNCTION"
        prompt_on
    else
        # Set default theme if no theme set
        lp_theme default
    fi
}

#####################
# Utility Functions #
#####################

# Remove all colors and escape characters of the given string and return a pure text
_lp_as_text() {
    # Remove all terminal sequences that we wrapped with $_LP_OPEN_ESC and
    # $_LP_CLOSE_ESC.
    printf '%s' "$1" | sed -r "s,$_LP_CLEAN_ESC,,g"
}

# Store $2 (or $?) as a true/false value in variable named $1
# $? is propagated
#   _lp_bool foo 5
#   => foo=false
#   _lp_bool foo 0
#   => foo=true
_lp_bool() {
    local res=${2:-$?}
    if (( res )); then
        eval "$1=false"
    else
        eval "$1=true"
    fi
    return "$res"
}

__lp_is_function() {
    if (( _LP_SHELL_bash )); then
        [[ $(LC_ALL=C \type -t "$1") == function ]]
    else
        [[ $(LC_ALL=C \type -w "$1") == *function ]]
    fi
}

# Count the number of lines in the input string. A faster subsitute for 'wc -l'.
# input: $1; a single string of input.
# return: $count; the number of newline characters in the string.
__lp_line_count() {
  local var="${1//[!$'\n']}"
  count=${#var}
}

__lp_pwd_tilde() {
    # Needs to be in a variable, as different versions of Bash treat '~' in a
    # substitution differently
    local tilde="~"
    lp_pwd_tilde="${PWD/#$HOME/$tilde}"
}

# insert a space on the right
_lp_sr() {
    [[ -n "$1" ]] && echo -nE "$1${LP_MARK_SPACE}"
}

# insert a space on the left
_lp_sl() {
    [[ -n "$1" ]] && echo -nE "${LP_MARK_SPACE}$1"
}

# insert two space, before and after
_lp_sb() {
    [[ -n "$1" ]] && echo -nE "${LP_MARK_SPACE}$1${LP_MARK_SPACE}"
}

# Generates a terminal escape sequence to format the terminal.
lp_terminal_format() {  # fg, bg, bold, underline, fallback_fg, fallback_bg
    lp_terminal_format=
    (( LP_ENABLE_COLOR )) || return 2

    local af_color ab_color fg=$1 bg=${2:-"-1"} previous_af_color=${_lp_last_af_color-}

    lp_terminal_format=${_LP_OPEN_ESC}${_LP_TI_RESET}

    if (( $fg >= _LP_TI_COLORS )) && [[ -n ${5-} ]]; then
        _lp_last_af_color=$5
    elif (( $fg == -2 )); then
        :  # do nothing, _lp_last_af_color already correct
    elif (( $fg == -3 )); then
        _lp_last_af_color=$_lp_last_ab_color
    elif (( $fg >= 0 )); then
        _lp_last_af_color=$fg
    else  # -1
        _lp_last_af_color=-1
    fi

    if (( ${_lp_last_af_color:-"-1"} >= 0 )); then
        __lp_foreground_color "$_lp_last_af_color" && lp_terminal_format+=$af_color
    fi

    if (( $bg >= _LP_TI_COLORS )) && [[ -n ${6-} ]]; then
        _lp_last_ab_color=$6
    elif (( $bg == -2 )); then
        :  # do nothing, _lp_last_ab_color already correct
    elif (( $bg == -3 )); then
        _lp_last_ab_color=$previous_af_color
    elif (( $bg >= 0 )); then
        _lp_last_ab_color=$bg
    else  # -1
        _lp_last_ab_color=-1
    fi

    if (( ${_lp_last_ab_color:-"-1"} >= 0 )); then
        __lp_background_color "$_lp_last_ab_color" && lp_terminal_format+=$ab_color
    fi

    # It turns out there are sequences to reset bold and underline to normal
    # (\E[22m and \E[24m in xterm), but they aren't universally supported. This
    # means we must reset to all defaults then enable if they are wanted.
    # Explicit is safer anyway.
    if (( ${3:-0} )); then
        lp_terminal_format+=$_LP_TI_BOLD
    fi

    if (( ${4:-0} )); then
        lp_terminal_format+=$_LP_TI_UNDERLINE
    fi

    lp_terminal_format+=$_LP_CLOSE_ESC
}

# Get a list of themes currently loaded. Looks for functions matching
# _lp_<theme>_theme_prompt().
# return: lp_theme_list; an array of theme names
__lp_theme_list() {
    lp_theme_list=()

    local -a _functions
    if (( _LP_SHELL_zsh )); then
        _functions=( "${(ko)functions[@]}" )
    else
        local IFS=$'\n'
        _functions=( $(declare -F) )
    fi

    local function
    for function in "${_functions[@]}"; do
        if [[ $function == *_lp_*_theme_prompt ]]; then
            function=${function#*_lp_}
            lp_theme_list+=("${function%_theme_prompt}")
        fi
    done
}

__lp_theme_bash_complete() {
    COMPREPLY=()
    local -a lp_theme_list
    local theme partial_theme=${2-}

    __lp_theme_list

    for theme in "${lp_theme_list[@]}"; do
        [[ -n $partial_theme && $theme != "$partial_theme"* ]] && continue
        COMPREPLY+=("$theme")
    done
}

__lp_theme_zsh_complete() {
    local -a lp_theme_list
    __lp_theme_list
    _describe 'theme' lp_theme_list
}

##########################
# Working Directory Path #
##########################

# Shorten the path of the current working directory
# * Show only the current directory
# * Show as much of the cwd path as possible, if shortened display a
#   leading mark, such as ellipses, to indicate that part is missing
# * show at least LP_PATH_KEEP leading dirs and current directory
__lp_shorten_path() {
    local ret= lp_pwd_tilde p
    __lp_pwd_tilde
    p="$lp_pwd_tilde"

    local mask="${LP_MARK_SHORTEN_PATH}"
    local -i max_len=$(( ${COLUMNS:-80} * LP_PATH_LENGTH / 100 ))

    if (( ${#p} <= max_len )); then
        ret="${p}"
    elif (( LP_PATH_KEEP == 0 )); then
        # len is over max len, show as much of the tail as is allowed
        ret="${p##*/}" # show at least complete current directory
        p="${p:0:${#p} - ${#ret}}"
        ret="${mask}${p:${#p} - (${max_len} - ${#ret} - ${#mask})}${ret}"
    else
        # len is over max len, show at least LP_PATH_KEEP leading dirs and
        # current directory
        local tmp="${p//\//}"
        local -i delims=$(( ${#p} - ${#tmp} ))

        for (( dir=0; dir < LP_PATH_KEEP; dir++ )); do
            (( dir == delims )) && break

            local left="${p#*/}"
            local name="${p:0:${#p} - ${#left}}"
            p="${left}"
            ret+="${name%/}/"
        done

        if (( delims <= LP_PATH_KEEP )); then
            # no dirs between LP_PATH_KEEP leading dirs and current dir
            ret+="${p##*/}"
        else
            local base="${p##*/}"

            p="${p:0:${#p} - ${#base}}"

            [[ ${ret} != "/" ]] && ret="${ret%/}" # strip trailing slash

            local -i len_left=$(( max_len - ${#ret} - ${#base} - ${#mask} ))

            ret+="${mask}${p:${#p} - ${len_left}}${base}"
        fi
    fi
    # Escape special chars
    __lp_escape "$ret"
    lp_shorten_path="$ret"
}

# In Bash shells, PROMPT_DIRTRIM is the number of directories to keep at the end
# of the displayed path (if "\w" is present in the PS1 var).
# Liquid Prompt can calculate this number under two conditions, path shortening
# must be disabled and PROMPT_DIRTRIM must be already set.
__lp_set_dirtrim() {
    local lp_pwd_tilde p
    __lp_pwd_tilde
    p="$lp_pwd_tilde"

    local -i max_len="${COLUMNS:-80}*$LP_PATH_LENGTH/100"
    local -i dt=0

    if (( ${#p} > max_len )); then
        local q="/${p##*/}"
        local show="$q"
        # +3 because of the ellipsis: "..."
        while (( ${#show}+3 < max_len )); do
            (( dt++ ))
            p="${p%$q}"
            q="/${p##*/}"
            show="$q$show"
        done
        (( dt == 0 )) && dt=1
    fi
    PROMPT_DIRTRIM=$dt
    # For debugging
    # echo PROMPT_DIRTRIM=$PROMPT_DIRTRIM >&2
}

###############
# Environment #
###############

# If we are connected with a X11 support
_lp_connected_display() {
    [[ -n "${DISPLAY-}" ]]
}

_lp_connection() {
    if [[ -n "${SSH_CLIENT-}${SSH2_CLIENT-}${SSH_TTY-}" ]]; then
        lp_connection=ssh
        return
    fi

    # tmux: see GH #304
    # TODO check on *BSD
    local whoami="$(LC_ALL=C who am i)"
    if [[ x"$whoami" != *'('* || x"$whoami" = *'(:'* || x"$whoami" = *'(tmux'* ]]; then
        lp_connection=lcl  # Local
        return
    fi

    local sess_parent="$(ps -o comm= -p "$PPID" 2> /dev/null)"
    if [[ "$sess_parent" = "su" || "$sess_parent" = "sudo" ]]; then
        lp_connection=su   # Remote su/sudo
    else
        lp_connection=tel  # Telnet
    fi
}

_lp_chroot() {
    if [[ -r /etc/debian_chroot ]]; then
        IFS= read -r lp_chroot </etc/debian_chroot
        [[ -n "$lp_chroot" ]] && return 0
    fi
    return 1
}

_lp_multiplexer() {
    if [[ -n ${TMUX-} ]]; then
        lp_mulitplexer=tmux
        return 0
    elif [[ "$TERM" == screen* ]]; then
        lp_mulitplexer=screen
        return 0
    fi
    return 1
}

_lp_http_proxy() {
    (( LP_ENABLE_PROXY )) || return 2

    if [[ -n "${http_proxy-}${HTTP_PROXY-}${https_proxy-}${HTTPS_PROXY-}${all_proxy-}${ALL_PROXY-}" ]]; then
        lp_http_proxy="${http_proxy:-${HTTP_PROXY:-${https_proxy:-${HTTPS_PROXY:-${all_proxy:-$ALL_PROXY}}}}}"
    else
        return 1
    fi
}

_lp_http_proxy_color() {
    _lp_http_proxy || return "$?"

    lp_http_proxy_color="${LP_COLOR_PROXY}${LP_MARK_PROXY}${NO_COL}"
}

_lp_python_env() {
    (( LP_ENABLE_VIRTUALENV )) || return 2

    # Why are these trunkated to the last '/' section? It has always been this
    # way, and the original author didn't explain why.
    if [[ -n "${VIRTUAL_ENV-}" ]]; then
        lp_python_env="${VIRTUAL_ENV##*/}"
    elif [[ -n "${CONDA_DEFAULT_ENV-}" ]]; then
        lp_python_env="${CONDA_DEFAULT_ENV##*/}"
    else
        return 1
    fi
}

_lp_python_env_color() {
    _lp_python_env || return "$?"

    lp_python_env_color="[${LP_COLOR_VIRTUALENV}${lp_python_env}${NO_COL}]"
}

_lp_software_collections() {
    (( LP_ENABLE_SCLS )) || return 2

    if [[ -n "${X_SCLS-}" ]]; then
        lp_software_collections="${X_SCLS%"${X_SCLS##*[![:space:]]}"}"
    else
        return 1
    fi
}

_lp_software_collections_color() {
    _lp_software_collections || return "$?"

    lp_software_collections_color="[${LP_COLOR_VIRTUALENV}${lp_software_collections}${NO_COL}]"
}

# return: 0 if login user, 1 if not, 2 if root
_lp_user() {
    if (( EUID == 0 )); then
        # if user is root
        return 2
    elif [[ "${USER}" != "$(logname 2>/dev/null || printf '%s' "${LOGNAME-}")" ]]; then
        # if user is not login user
        return 1
    else
        return 0
    fi
}

# Test the code with the commands:
#   sudo id   # sudo, enter your credentials
#   sudo -K   # revoke your credentials
_lp_sudo_active() {
    (( LP_ENABLE_SUDO )) || return 2
    \sudo -n true 2>/dev/null || return 1
}

_lp_sudo_active_color() {
    (( LP_ENABLE_SUDO )) || return 2

    if _lp_sudo_active; then
        lp_sudo_active_color=$LP_COLOR_MARK_SUDO
    else
        lp_sudo_active_color=$LP_COLOR_MARK_NO_SUDO
    fi
}

_lp_hostname() {
    # Only process hostname elements if we haven't turned them off
    if (( LP_HOSTNAME_ALWAYS != -1 )); then

        # Which host symbol should we use?
        if (( LP_ENABLE_FQDN )); then
            LP_HOST_SYMBOL="${_LP_FQDN_SYMBOL}"
        else
            LP_HOST_SYMBOL="${_LP_HOST_SYMBOL}"
        fi

        lp_hostname=${LP_HOST_SYMBOL}

        _lp_connection
        if [[ $lp_connection == lcl ]] && ! (( LP_HOSTNAME_ALWAYS )); then
            # no hostname if local
            return 1
        fi
    else
        return 1
    fi
}

# Put the hostname if not locally connected
# color it in cyan within SSH, and a warning red if within telnet
# else display the host without color
_lp_hostname_color() {
    if _lp_connected_display; then
        lp_hostname_color="${LP_COLOR_X11_ON}"
    else
        lp_hostname_color="${LP_COLOR_X11_OFF}"
    fi

    if _lp_chroot; then
        lp_hostname_color+="(${lp_chroot})"
    fi

    if _lp_hostname; then
        case "$lp_connection" in
            lcl)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_HOST}${lp_hostname}${NO_COL}"
                ;;
            ssh)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_SSH}${lp_hostname}${NO_COL}"
                ;;
            su)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_SU}${lp_hostname}${NO_COL}"
                ;;
            tel)
                lp_hostname_color+="${LP_MARK_X11}${LP_COLOR_TELNET}${lp_hostname}${NO_COL}"
                ;;
            *)
                lp_hostname_color+="${LP_MARK_X11}${NO_COL}${lp_hostname}" # defaults to no color
                ;;
        esac
    else
        if [[ -n $lp_chroot ]]; then
            # End the color of the chroot
            lp_hostname_color+=${NO_COL}
        else
            # Nothing to display
            lp_hostname_color=""
            return 1
        fi
    fi
}

################
# Related jobs #
################

# Return the count of detached screens sessions and/or tmux sessions running
# on the host
# return: lp_detached_sessions; the number of detached sessions
_lp_detached_sessions() {
    local -i count=0
    (( _LP_ENABLE_SCREEN )) && count=$(screen -ls 2> /dev/null | \grep -c '[Dd]etach[^)]*)$')
    (( _LP_ENABLE_TMUX )) && count+=$(tmux list-sessions 2> /dev/null | \grep -cv 'attached')
    lp_detached_sessions=$count
    (( lp_detached_sessions ))
}

# Return the count of attached running jobs (started with $ myjob &) and/or
# stopped jobs (suspended with Ctrl-Z)
# return: lp_running_jobs; the number of running shell jobs
#         lp_stopped_jobs; the number of stopped shell jobs
_lp_jobcount() {
    local -i count
    # Count running jobs
    # The $(...) syntax strips trailing newlines, so add a character to the end
    # then remove it to prevent that. Otherwise 0 and 1 jobs look the same.
    jobs="$(jobs -r; printf x)"
    __lp_line_count "${jobs%x}"
    lp_running_jobs=$count

    # Count stopped jobs
    jobs="$(jobs -s; printf x)"
    __lp_line_count "${jobs%x}"
    lp_stopped_jobs=$count

    (( lp_running_jobs || lp_stopped_jobs ))
}

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
_lp_jobcount_color() {
    (( LP_ENABLE_JOBS )) || return 2

    lp_jobcount_color=

    _lp_detached_sessions && lp_jobcount_color="${LP_COLOR_JOB_D}${lp_detached_sessions}d${NO_COL}"

    _lp_jobcount
    if (( lp_running_jobs > 0 )); then
        [[ -n "$lp_jobcount_color" ]] && lp_jobcount_color+='/'
        lp_jobcount_color+="${LP_COLOR_JOB_R}${lp_running_jobs}&${NO_COL}"
    fi
    if (( lp_stopped_jobs > 0 )); then
        [[ -n "$lp_jobcount_color" ]] && lp_jobcount_color+='/'
        lp_jobcount_color+="${LP_COLOR_JOB_Z}${lp_stopped_jobs}z${NO_COL}"
    fi

    [[ -n "$lp_jobcount_color" ]]
}

######################
# VCS branch display #
######################

_lp_are_vcs_enabled() {
    local path
    for path in "${LP_DISABLED_VCS_PATHS[@]}"; do
        if [[ -n "$path" && "$PWD" == "$path"* ]]; then
            return 1
        fi
    done
    return 0
}

# Search upwards through a directory structure looking for a sign of a VCS
# repository. Used to avoid invoking VCS binaries to discover if in a repo.
# Checks $LP_DISABLED_VCS_PATH and returns false if a match is found.
# Otherwise returns the first matching repository.
# return: true if in repo, false if not (1) or path disabled (2)
#         lp_vcs_type; the string ID of the VCS controlling this directory.
#         lp_vcs_root; the path to the root of the found repository.
_lp_find_vcs() {
    if ! _lp_are_vcs_enabled; then
        lp_vcs_type="disabled"
        lp_vcs_root=
        return 2
    fi

    lp_vcs_root="$PWD"
    while [[ -n "$lp_vcs_root" ]]; do
        for vcs in "${_LP_ENABLED_VCSS[@]}"; do
            if [[ -d "$lp_vcs_root/.$vcs" ]]; then
                lp_vcs_type="$vcs"
                return 0
            fi
        done
        lp_vcs_root="${lp_vcs_root%/*}"
    done

    lp_vcs_type=
    lp_vcs_root=
    return 1
}

# Set the prompt mark to ± if git, to ☿ if mercurial, to ‡ if subversion
# to # if root and else $
# input: lp_vcs_type; the string ID of the VCS type, can be set by
#          _lp_find_vcs().
# return: lp_smart_mark; the symbol of the selected prompt mark
_lp_smart_mark() {
    case "${1:-$lp_vcs_type}" in
        git)
            lp_smart_mark="$LP_MARK_GIT"

            if [[ -n "${VCSH_DIRECTORY-}" ]]; then
                lp_smart_mark="$LP_MARK_VCSH$LP_MARK_GIT$LP_MARK_VCSH"
            elif [[ -d "${lp_vcs_root}/.git/svn" ]]; then
                lp_smart_mark="$LP_MARK_GIT$LP_MARK_SVN"
            fi
            ;;
        hg)       lp_smart_mark="$LP_MARK_HG";;
        disabled) lp_smart_mark="$LP_MARK_DISABLED";;
        *)        lp_smart_mark="$LP_MARK_DEFAULT";;
    esac
}

# GENERIC VCS #

# Set a color depending on the branch state:
# - green if the repository is up to date
# - yellow if there is some commits not pushed
# - red if there is changes to commit
# Add the number of pending commits and the impacted lines.
# return: lp_vcs_details_color; the detailed formatted string of repo details
_lp_vcs_details_color() {
    local branch
    if _lp_vcs_branch; then
        branch="$lp_vcs_branch"

        if _lp_vcs_bookmark; then
            branch+=": $lp_vcs_bookmark"
        fi
    elif _lp_vcs_bookmark; then
        branch="$lp_vcs_bookmark"
    elif _lp_vcs_tag; then
        branch="tag: $lp_vcs_tag"
    else
        _lp_vcs_commit_id
        branch="${lp_vcs_commit_id:0:7}"
    fi

    lp_vcs_details_color="$LP_COLOR_UP"

    local has_commit=
    if _lp_vcs_commits_off_remote; then
        lp_vcs_details_color="$LP_COLOR_COMMITS_BEHIND"
        if [[ "$lp_vcs_commit_ahead" -ne "0" && "$lp_vcs_commit_behind" -ne "0" ]]; then
            has_commit="${LP_COLOR_COMMITS}+$lp_vcs_commit_ahead${NO_COL}/${LP_COLOR_COMMITS_BEHIND}-$lp_vcs_commit_behind${NO_COL}"
        elif [[ "$lp_vcs_commit_ahead" -ne "0" ]]; then
            has_commit="${LP_COLOR_COMMITS}$lp_vcs_commit_ahead${NO_COL}"
            lp_vcs_details_color="$LP_COLOR_COMMITS"
        elif [[ "$lp_vcs_commit_behind" -ne "0" ]]; then
            has_commit="${LP_COLOR_COMMITS_BEHIND}-$lp_vcs_commit_behind${NO_COL}"
        fi
    fi

    local ret has_lines=
    if _lp_vcs_uncommitted_lines; then
        _lp_vcs_unstaged_lines; ret=$?
        # Only show unstaged changes if the VCS supports staging, otherwise
        # show uncommitted changes
        if (( ret == 0 )); then
            has_lines="+$lp_vcs_unstaged_i_lines/-$lp_vcs_unstaged_d_lines"
        elif (( ret == 1 )); then
            has_lines="+0/-0"
        else
            has_lines="+$lp_vcs_uncommitted_i_lines/-$lp_vcs_uncommitted_d_lines"
        fi
        lp_vcs_details_color="$LP_COLOR_CHANGES"
    fi

    lp_vcs_details_color+="$branch"
    if [[ -n "$has_lines" || -n "$has_commit" ]]; then
        lp_vcs_details_color+="${NO_COL}${LP_MARK_VCS_OPEN}"
        if [[ -n "$has_lines" ]]; then
            lp_vcs_details_color+="${LP_COLOR_DIFF}${has_lines}${NO_COL}${has_commit:+,}"
        fi
        lp_vcs_details_color+="${has_commit}${LP_MARK_VCS_CLOSE}"
    fi

    if _lp_vcs_stash_count; then
        lp_vcs_details_color+="$LP_COLOR_COMMITS$LP_MARK_STASH"
    fi

    if _lp_vcs_untracked_files; then
        lp_vcs_details_color+="$LP_COLOR_CHANGES$LP_MARK_UNTRACKED"
    fi

    if _lp_vcs_head_status; then
        lp_vcs_details_color+=" $LP_COLOR_CHANGES$lp_vcs_head_status"
        if [[ -n "${lp_vcs_head_details-}" ]]; then
            lp_vcs_details_color+="(${lp_vcs_head_details})"
        fi
    fi

    lp_vcs_details_color+="$NO_COL"
}

# Check if the detected VCS is enabled in Liquidprompt and the current
# directory is a valid repository of that type. This check should be done
# before running any other _lp_vcs_* data functions, but can be omitted for
# speed reasons if the checks done by _lp_find_vcs() are good enough.
# return: false if VCS disabled (2) or not a valid repo (1), true otherwise.
_lp_vcs_active() {
    "_lp_${lp_vcs_type}_active" 2>/dev/null
}

# Get the branch name of the repo in the current directory.
# return: true if a valid VCS branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_vcs_branch() {
    "_lp_${lp_vcs_type}_branch" 2>/dev/null
}

# Get the bookmark name of the repo in the current directory.
# Most VCS providers don't support this.
# return: true if a valid VCS bookmark is active.
#         lp_vcs_bookmark; the name of the current bookmark.
_lp_vcs_bookmark() {
    "_lp_${lp_vcs_type}_bookmark" 2>/dev/null
}

# Get a tag name of the repo in the current directory. Note that not all VCS
# providers support tags that match to one and only one commit object.
# return: true if a valid VCS tag matches the HEAD commit. False if no tag
#             matches (1) or unique tags are not supported (2+).
#         lp_vcs_tag; the name of (one of) the current tag(s).
_lp_vcs_tag() {
    "_lp_${lp_vcs_type}_tag" 2>/dev/null
}

# Get the current short commit string for the repo in the current directory.
# Some VCS providers identify commits by a hash, others use a revision number.
# The returned string should be unique enough that a user can identify the
# commit. This should never fail if the current directory is a valid repo.
# return: lp_vcs_commit_id; a short string that can ID the current commit.
_lp_vcs_commit_id() {
    "_lp_${lp_vcs_type}_commit_id" 2>/dev/null
}

# Get additional information if the repo is in a special or unusual state.
# Many VCS providers don't have such information, and many users either don't
# care to see it or rarely get in a repo state that has any such info. This
# info is unlikely to be similar across VCSs, and should probably be displayed
# to a user without manipulation.
# return: true if any extra state is found, false if not (1) or the VCS
#             provider does not support any useful extra info (2+).
#         lp_vcs_head_status; the extra repo state
#         lp_vcs_head_details; optional extra details, like progress in a
#             rebase. This might not be set, so protect it with "${var-}".
_lp_vcs_head_status() {
    "_lp_${lp_vcs_type}_head_status" 2>/dev/null
}

# Get the number of stashes in the repo. Not all VCS providers support stashes.
# return: true if any stashes are found, false if not (1) or the VCS does not
#             support stashes (2+).
#         lp_vcs_stash_count; the number of stashes
_lp_vcs_stash_count() {
    "_lp_${lp_vcs_type}_stash_count" 2>/dev/null
}

# Get the number of commits ahead and behind the upstream branch. Many VCS
# providers cannot provide these numbers, simply because they simply don't work
# that way.
# return: true if any commits differ from the remote branch, false if not (1),
#             no upstream branch exists (2), or not supported by the VCS (3+).
#         lp_vcs_commit_behind; the number of commits that only exist remotely.
#         lp_vcs_commit_ahead; the number of commits that only exist locally.
_lp_vcs_commits_off_remote() {
    "_lp_${lp_vcs_type}_commits_off_remote" 2>/dev/null
}

# Get the number of untracked aka extra files in the repo. This count excludes
# files explicitly ignored by the user.
# return: true if any untracked files are found.
#         lp_vcs_untracked_files; the number of untracked files.
_lp_vcs_untracked_files() {
    "_lp_${lp_vcs_type}_untracked_files" 2>/dev/null
}

# Get the number of changed files compared to the last or checked out commit.
# return: true if any files differ from the latest commit.
#         lp_vcs_uncommitted_files; the number of lines changed.
_lp_vcs_uncommitted_files() {
    "_lp_${lp_vcs_type}_uncommitted_files" 2>/dev/null
}

# Get the number of changed lines compared to the last or checked out commit.
# return: true if any lines differ from the latest commit.
#         lp_vcs_uncommitted_i_lines; the number of lines inserted.
#         lp_vcs_uncommitted_d_lines; the number of lines deleted.
_lp_vcs_uncommitted_lines() {
    "_lp_${lp_vcs_type}_uncommitted_lines" 2>/dev/null
}

# Get the number of changed files compared to staging. Many VCS providers do
# not have a staging area, and one might need to fall back to
# uncommitted_files() instead.
# return: true if any files differ from staging, false if not (1), or the VCS
#             does not support staging (2).
#         lp_vcs_unstaged_files; the number of files changed.
_lp_vcs_unstaged_files() {
    "_lp_${lp_vcs_type}_unstaged_files" 2>/dev/null
}

# Get the number of changed lines compared to staging. Many VCS providers do
# not have a staging area, and one might need to fall back to
# uncommitted_lines() instead.
# return: true if any lines differ from staging, false if not (1), or the VCS
#             does not support staging (2).
#         lp_vcs_unstaged_i_lines; the number of lines inserted.
#         lp_vcs_unstaged_d_lines; the number of lines deleted.
_lp_vcs_unstaged_lines() {
    "_lp_${lp_vcs_type}_unstaged_lines" 2>/dev/null
}

# GIT #

# Check if Git is enabled in Liquidprompt and the current directory is a valid
# Git repository. This check should be done before running any other _lp_git_*
# data functions.
# return: false if Git disabled (2) or not a valid repo (1), true otherwise.
_lp_git_active() {
    (( LP_ENABLE_GIT )) || return 2
    \git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 1
}

# Get the branch name of the Git repo in the current directory.
# return: true if a valid Git branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_git_branch() {
    local branch ret
    # Recent versions of Git support the --short option for symbolic-ref, but
    # not 1.7.9 (Ubuntu 12.04)
    if branch="$(\git symbolic-ref -q HEAD 2>/dev/null)"; then
        __lp_escape "${branch#refs/heads/}"
        lp_vcs_branch="$ret"
    else
        return 1
    fi
}

# Get a tag name of the Git repo in the current directory.
# return: true if a valid Git tag matches the HEAD commit.
#         lp_vcs_tag; the name of (one of) the current tag(s).
_lp_git_tag() {
    local tag ret
    if tag="$(\git describe --tags --exact-match 2>/dev/null)"; then
        __lp_escape "$tag"
        lp_vcs_tag="$ret"
    else
        return 1
    fi
}

# Get the current full commit hash of the repo in the current directory.
# return: lp_vcs_commit_id; the hash of the HEAD commit.
_lp_git_commit_id() {
    lp_vcs_commit_id="$(\git rev-parse -q HEAD 2>/dev/null)"
}

# Get additional information if HEAD is in merging, rebasing
# or cherry-picking state.
# This function depends on _lp_find_vcs() being run first to set $lp_vcs_root.
# return: true if any extra state is found.
#         lp_vcs_head_status; the extra repo state.
#         lp_vcs_head_details; optional extra details, like progress in a rebase.
_lp_git_head_status() {
    local gitdir="${lp_vcs_root}/.git" IFS= step total

    if [[ -f "${gitdir}/MERGE_HEAD" ]]; then
        lp_vcs_head_status="MERGING"
    elif [[ -d "${gitdir}/rebase-merge" ]]; then
        read step <"${gitdir}/rebase-merge/msgnum"
        read total <"${gitdir}/rebase-merge/end"
        if [ -f "${gitdir}/rebase-merge/interactive" ]; then
            lp_vcs_head_status="REBASE-i"
        else
            lp_vcs_head_status="REBASE-m"
        fi
    elif [[ -d "${gitdir}/rebase-apply" ]]; then
        read step <"${gitdir}/rebase-apply/next"
        read total <"${gitdir}/rebase-apply/last"
        if [ -f "${gitdir}/rebase-apply/rebasing" ]; then
            lp_vcs_head_status="REBASE"
        elif [ -f "${gitdir}/rebase-apply/applying" ]; then
            lp_vcs_head_status="AM"
        else
            lp_vcs_head_status="AM/REBASE"
        fi
    elif [[ -f "${gitdir}/CHERRY_PICK_HEAD" ]]; then
        lp_vcs_head_status="CHERRY-PICKING"
    elif [[ -f "${gitdir}/REVERT_HEAD" ]]; then
        lp_vcs_head_status="REVERTING"
    elif [[ -f "${gitdir}/BISECT_START" ]]; then
        lp_vcs_head_status="BISECTING"
    else
        return 1
    fi

    if [[ -n "$step" && -n "$total" ]]; then
        lp_vcs_head_details="${step}/${total}"
    else
        lp_vcs_head_details=
    fi
}

# Get the number of Git stashes in the repo.
# return: true if any stashes are found.
#         lp_vcs_stash_count; the number of stashes.
_lp_git_stash_count() {
    lp_vcs_stash_count="$(\git rev-list --walk-reflogs --count refs/stash 2>/dev/null)"
    (( lp_vcs_stash_count ))
}

# Count commits behind and ahead on the remote tracking branch of the current
# local branch.
# return: false if no commits ahead or behind (1) or if no tracking upstream
#         branch exists (2).
#         lp_vcs_commit_behind: number of commits behind the remote branch.
#         lp_vcs_commit_ahead: number of commits ahead of the remote branch.
_lp_git_commits_off_remote() {
    local counts
    # The "@{upstream}" notation was added in Git 1.7.0, so this should work for everyone
    counts="$(\git rev-list --count --left-right '@{upstream}...HEAD' 2>/dev/null)" || return 2
    IFS=$' \t' read lp_vcs_commit_behind lp_vcs_commit_ahead <<<"$counts"
    (( lp_vcs_commit_behind || lp_vcs_commit_ahead ))
}

# Get the number of untracked files in the repo.
# return: true if any untracked files exist.
#         lp_vcs_untracked_files; the number of untracked files.
_lp_git_untracked_files() {
    lp_vcs_untracked_files="$(LC_ALL=C \git status --porcelain 2>/dev/null | \grep -c '^??')"
    (( lp_vcs_untracked_files ))
}

# Get the number of changed files compared to HEAD.
# return: true if any files differ from HEAD.
#         lp_vcs_uncommitted_files; the number of lines changed.
_lp_git_uncommitted_files() {
    local stat
    stat="$(LC_ALL=C \git diff --shortstat HEAD -- 2>/dev/null)"

    if [[ "$stat" = *changed* ]]; then
        stat="${stat/ file*}"
        lp_vcs_uncommitted_files=${stat//[$' \t']}
    else
        return 1
    fi
}

# Get the number of changed lines compared to HEAD.
# return: true if any lines differ from HEAD.
#         lp_vcs_uncommitted_i_lines; the number of lines inserted.
#         lp_vcs_uncommitted_d_lines; the number of lines deleted.
_lp_git_uncommitted_lines() {
    local stat
    stat="$(LC_ALL=C \git diff --shortstat HEAD -- 2>/dev/null)"

    stat=${stat/*changed, /} # removing "n file(s) changed"

    if [[ "$stat" = *insertion* ]]; then
        lp_vcs_uncommitted_i_lines=${stat/ inser*}
    else
        lp_vcs_uncommitted_i_lines=0
    fi

    if [[ "$stat" = *deletion* ]]; then
        stat=${stat/*\(+\), }
        lp_vcs_uncommitted_d_lines=${stat/ del*/}
    else
        lp_vcs_uncommitted_d_lines=0
    fi

    (( lp_vcs_uncommitted_i_lines || lp_vcs_uncommitted_d_lines ))
}

# Get the number of changed files compared to staging.
# return: true if any files differ from staging.
#         lp_vcs_unstaged_files; the number of files changed.
_lp_git_unstaged_files() {
    local stat
    stat="$(LC_ALL=C \git diff --shortstat 2>/dev/null)"

    if [[ "$stat" = *changed* ]]; then
        stat="${stat/ file*}"
        lp_vcs_unstaged_files=${stat//[$' \t']}
    else
        return 1
    fi
}

# Get the number of changed lines compared to staging.
# return: true if any lines differ from staging.
#         lp_vcs_unstaged_i_lines; the number of lines inserted.
#         lp_vcs_unstaged_d_lines; the number of lines deleted.
_lp_git_unstaged_lines() {
    local stat
    stat="$(LC_ALL=C \git diff --shortstat 2>/dev/null)"

    stat=${stat/*changed, /} # removing "n file(s) changed"

    if [[ "$stat" = *insertion* ]]; then
        lp_vcs_unstaged_i_lines=${stat/ inser*}
    else
        lp_vcs_unstaged_i_lines=0
    fi

    if [[ "$stat" = *deletion* ]]; then
        stat=${stat/*\(+\), }
        lp_vcs_unstaged_d_lines=${stat/ del*/}
    else
        lp_vcs_unstaged_d_lines=0
    fi

    (( lp_vcs_unstaged_i_lines || lp_vcs_unstaged_d_lines ))
}

# MERCURIAL #
# Note that Mercurial has no staging area

# Check if Mercurial is enabled in Liquidprompt and the current directory is a
# valid Mercurial repository. Note that as 'hg' is written in Python, the
# startup cost is quite heavy, and as of this writing, 'hg root' does nothing
# more than look for a '.hg' directory, not examine the contents.
# return: false if Mercurial disabled (2) or not a valid repo (1), true
#             otherwise.
_lp_hg_active() {
    (( LP_ENABLE_HG )) || return 2
    \hg root >/dev/null 2>&1 || return 1
}

# Get the branch name of the Mercurial repo in the current directory.
# Note that Mercurial commits are always "on a branch", so checking out a
# non-head commit will still return a branch name. A closer analog to Git
# branches are Mercurial bookmarks.
# return: true if a valid Mercurial branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_hg_branch() {
    local branch ret
    if branch="$(\hg branch 2>/dev/null)"; then
        __lp_escape "$branch"
        lp_vcs_branch="$ret"
    else
        # This should never happen. Should this function return a branch name
        # only if the head of the branch is checked out? But there can be
        # multiple heads of a branch...
        return 1
    fi
}

# Get the bookmark name of the Mercurial repo in the current directory.
# Mercurial bookmarks work more like Git branches.
# return: true if a valid Mercurial bookmark is checked out.
#         lp_vcs_bookmark; the name of the current bookmark.
_lp_hg_bookmark() {
    local bookmark ret
    if bookmark="$(\hg bookmark --list --quiet . 2>/dev/null)"; then
        __lp_escape "$bookmark"
        lp_vcs_bookmark="$ret"
    else
        return 1
    fi
}

# Get the most recent tag that refers to the current revision.
# return: true if a valid Mercurial tag is checked out.
#         lp_vcs_tag; the name of the current tag.
_lp_hg_tag() {
    local tags ret
    tags="$(\hg identify --template='{tags}' 2>/dev/null)"
    if [[ -n "$tags" ]]; then
        # Tags are separated by ':', get the first one
        __lp_escape "${tags%%:*}"
        lp_vcs_tag="$ret"
    else
        return 1
    fi
}

# Get the current global revision id for the repo in the current directory.
# return: lp_vcs_commit_id; the global hash of the current revision.
_lp_hg_commit_id() {
    lp_vcs_commit_id="$(\hg identify --id 2>/dev/null)"
}

# Get additional information if the repo is in any unfinished state.
# This function depends on _lp_find_vcs() being run first to set $lp_vcs_root.
# return: true if any unfinished state is found.
#         lp_vcs_head_status; the extra repo state.
_lp_hg_head_status() {
    local hgdir="${lp_vcs_root}/.hg"
    if [[ -d "${hgdir}/merge" ]]; then
        lp_vcs_head_status="MERGING"
    elif [[ -f "${hgdir}/rebasestate" ]]; then
        lp_vcs_head_status="REBASING"
    elif [[ -f "${hgdir}/updatestate" ]]; then
        lp_vcs_head_status="UPDATING"
    elif [[ -f "${hgdir}/bisect.state" ]]; then
        lp_vcs_head_status="BISECTING"
    elif [[ -f "${hgdir}/shelvedstate" ]]; then
        lp_vcs_head_status="SHELVING"
    elif [[ -f "${hgdir}/graftstate" ]]; then
        lp_vcs_head_status="GRAFTING"
    else
        return 1
    fi
}

# Get the number of Mercurial shelves in the repo.
# return: true if any shelves are found.
#         lp_vcs_stash_count; the number of shelves.
_lp_hg_stash_count() {
    local shelves count
    shelves="$(\hg shelve --list 2>/dev/null; printf x)"
    _lp_line_count "${shelves%x}"
    lp_vcs_stash_count="$count"
    (( lp_vcs_stash_count ))
}

# Mercurial doesn't keep a local copy of the remote state, so checking this
# will require a connection to the remote server. This means it is often
# prohibitively time expensive, and therefore shouldn't be used in a prompt.
# https://github.com/nojhan/liquidprompt/issues/217
# return: always false (3: disabled).
_lp_hg_commits_off_remote() {
    #commits=$(\hg outgoing --no-merges 2>/dev/null | \grep -c '\(^changeset\:\)')
    return 3
}

# Get the number of untracked files in the Mercurial repo.
# return: true if any untracked files are found.
#         lp_vcs_untracked_files; the number of untracked files.
_lp_hg_untracked_files() {
    local untracked
    untracked="$(\hg status --unknown --template '{status}' 2>/dev/null)"
    lp_vcs_untracked_files="${#untracked}"
    (( lp_vcs_untracked_files ))
}

# Get the number of changed files compared to the base revision.
# return: true if any files differ from the base revision.
#         lp_vcs_uncommitted_files; the number of files changed.
_lp_hg_uncommitted_files() {
    local files
    files="$(\hg status --modified --template '{status}' 2>/dev/null)"
    lp_vcs_uncommitted_files="${#files}"
    (( lp_vcs_uncommitted_files ))
}

# Get the number of changed lines compared to the base revision.
# return: true if any lines differ from the base revision.
#         lp_vcs_uncommitted_i_lines; the number of lines inserted.
#         lp_vcs_uncommitted_d_lines; the number of lines deleted.
_lp_hg_uncommitted_lines() {
    IFS=' ' read lp_vcs_uncommitted_i_lines lp_vcs_uncommitted_d_lines \
        <<<"$(\hg diff --stat 2>/dev/null | sed -n '$ s/^.*, \([0-9]*\) .*, \([0-9]*\).*$/\1 \2/p')"

    (( lp_vcs_uncommitted_i_lines || lp_vcs_uncommitted_d_lines ))
}

##########
# Title #
##########

_lp_title() {
    (( LP_ENABLE_TITLE )) || return 2

    # Get the input as pure text
    _lp_generated_title=$(_lp_as_text "${1-}")
}

_lp_raw_title() {
    (( LP_ENABLE_TITLE )) || return 2

    _lp_generated_title=${1-}
}

lp_title() {
    (( LP_ENABLE_TITLE )) || return 2

    if [[ -n ${1+x} ]]; then
        _lp_manual_title=$1
    else
        unset _lp_manual_title
    fi
}

#################
# Default theme #
#################

_lp_default_theme_activate() {
    # Default value for LP_PERM when LP_ENABLE_PERM is 0
    LP_PERM=${LP_MARK_PERM}   # without color

    _lp_user
    local -i user=$?

    # Yellow for root, bold if the user is not the login one, else no color.
    if (( user < 2 )); then  # if user is not root
        # if user is not login user
        if (( user == 1 )); then
            LP_USER="${LP_COLOR_USER_ALT}${_LP_USER_SYMBOL}${NO_COL}"
        elif (( LP_USER_ALWAYS )); then
            LP_USER="${LP_COLOR_USER_LOGGED}${_LP_USER_SYMBOL}${NO_COL}"
        else
            LP_USER=
        fi
        if (( LP_ENABLE_SUDO )); then
            LP_COLOR_MARK_NO_SUDO="$LP_COLOR_MARK"
        fi
    else # root!
        LP_USER="${LP_COLOR_USER_ROOT}${_LP_USER_SYMBOL}${NO_COL}"
        LP_COLOR_MARK="${LP_COLOR_MARK_ROOT}"
        LP_COLOR_PATH="${LP_COLOR_PATH_ROOT}"
        if (( ! LP_ENABLE_VCS_ROOT )); then
            LP_MARK_DISABLED="$LP_MARK_DEFAULT"
        fi
    fi

    # The connection is not expected to change from inside the shell, so we
    # build this just once
    _lp_hostname_color
    LP_HOST="$lp_hostname_color"

    # If we are running in a terminal multiplexer, brackets are colored
    if _lp_multiplexer; then
        LP_BRACKET_OPEN="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_OPEN}${NO_COL}"
        LP_BRACKET_CLOSE="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
    else
        LP_BRACKET_OPEN="${LP_COLOR_IN_LOCAL}${LP_MARK_BRACKET_OPEN}${NO_COL}"
        LP_BRACKET_CLOSE="${LP_COLOR_IN_LOCAL}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
    fi

    if (( LP_ENABLE_TIME )); then
        # Never changes
        LP_TIME="${LP_COLOR_TIME}${_LP_TIME_SYMBOL}${NO_COL} "
    else
        LP_TIME=
    fi
}

_lp_default_theme_directory() {
    # LP_PERM: shows a ":"
    # - colored in green if user has write permission on the current dir
    # - colored in red if not
    # - can set another symbol with LP_MARK_PERM
    if (( LP_ENABLE_PERM )); then
        if [[ -w "${PWD}" ]]; then
            LP_PERM="${LP_COLOR_WRITE}${LP_MARK_PERM}${NO_COL}"
        else
            LP_PERM="${LP_COLOR_NOWRITE}${LP_MARK_PERM}${NO_COL}"
        fi
    fi

    LP_PWD="${LP_COLOR_PATH}${lp_path}${NO_COL}"
}

_lp_default_theme_prompt() {
    if (( LP_ENABLE_ERR && lp_err != 0 )); then
        LP_ERR=" $LP_COLOR_ERR$lp_err$NO_COL"
    else
        LP_ERR=
    fi

    # left of main prompt: space at right
    if _lp_jobcount_color; then
        LP_JOBS="$lp_jobcount_color "
    else
        LP_JOBS=
    fi
    if _lp_sudo_active_color; then
        LP_COLOR_MARK="$lp_sudo_active_color"
    fi

    # in main prompt: no space
    if _lp_http_proxy_color; then
        LP_PROXY="$lp_http_proxy_color"
    else
        LP_PROXY=
    fi

    if _lp_python_env_color; then
        LP_VENV=" $lp_python_env_color"
    else
        LP_VENV=
    fi

    if _lp_software_collections_color; then
        LP_SCLS=" $lp_software_collections_color"
    else
        LP_SCLS=
    fi

    if _lp_find_vcs; then
        if [[ "$LP_ENABLE_OHMYGIT,$lp_vcs_type" = 1,git* ]]; then
            local omg_prompt
            if omg_prompt="$(_omg_build_prompt)"; then
                LP_VCS=" $omg_prompt"
            else
                LP_VCS=
            fi
        elif _lp_vcs_details_color; then
            LP_VCS=" $lp_vcs_details_color"
        else
            LP_VCS=
        fi
    else
        LP_VCS=
    fi

    _lp_smart_mark
    LP_MARK="${lp_smart_mark}${NO_COL} "

    if [[ -f "${LP_PS1_FILE-}" ]]; then
        source "$LP_PS1_FILE"
    fi

    if [[ -z "${LP_PS1-}" ]]; then
        # add time and jobs
        PS1="${LP_TIME}${LP_JOBS}"
        # add user, host and permissions colon
        PS1+="${LP_BRACKET_OPEN}${LP_USER}${LP_HOST}${LP_PERM}"

        PS1+="${LP_PWD}${LP_BRACKET_CLOSE}${LP_SCLS}${LP_VENV}${LP_PROXY}"

        # Add VCS infos
        # If root, the info has not been collected unless LP_ENABLE_VCS_ROOT
        # is set.
        PS1+="${LP_VCS}"

        # add return code and prompt mark
        PS1+="${LP_ERR}${LP_MARK_PREFIX}${LP_COLOR_MARK}${LP_MARK}"

        # Get the current prompt on the fly and make it a title
        _lp_title "${LP_TAG:-"$PS1"}"
    else
        PS1=$LP_PS1
    fi
}

########################
# Construct the prompt #
########################

__lp_set_prompt() {
    # Display the return value of the last command, if different from zero
    # As this get the last returned code, it should be called first
    local -i lp_err=$?

    # bash: execute the old prompt hook
    eval "$LP_OLD_PROMPT_COMMAND"

    # if change of working directory
    if [[ "${LP_OLD_PWD-}" != "LP:$PWD" ]]; then
        __lp_path

        "$_LP_THEME_DIRECTORY_FUNCTION"

        # Prefix with 'LP:' to prevent Zsh with AUTO_NAME_DIRS enabled using
        # this var as a name for the working directory, that will be used by
        # the '%' and related prompt sequences.
        # See https://github.com/nojhan/liquidprompt/issues/124 for details.
        LP_OLD_PWD="LP:$PWD"
    fi

    "$_LP_THEME_PROMPT_FUNCTION"

    if (( LP_ENABLE_TITLE )); then
        PS1="${_LP_OPEN_ESC}${LP_TITLE_OPEN}${_lp_manual_title:-${_lp_generated_title-${SHELL-}}}${LP_TITLE_CLOSE}${_LP_CLOSE_ESC}${PS1}"
    fi
}

prompt_tag() {
    export LP_TAG="$1"
}

prompt_fulleval() {
    LP_OLD_PWD=""
}

# Activate Liquid Prompt
prompt_on() {
    # Reset so all PWD dependent variables are computed after loading
    LP_OLD_PWD=""

    # if Liquid Prompt has not been already set
    if [[ -z "${LP_OLD_PS1-}" ]]; then
        LP_TAG=""
        LP_OLD_PS1="$PS1"
        if (( _LP_SHELL_bash )); then
            LP_OLD_PROMPT_COMMAND="${PROMPT_COMMAND-}"
            _LP_OLD_SHOPT="$(shopt -p promptvars)"
        else # zsh
            LP_OLD_PROMPT_COMMAND=""
            _LP_ZSH_PROMPT_THEME=""
            if [[ -n "${prompt_theme-}" && "$prompt_theme" != off ]]; then
                _LP_ZSH_PROMPT_THEME="$prompt_theme"
                # Disable the prompt to disable its precmd hook
                prompt off
            fi
            _LP_OLD_SETOPT=()
            # Dump option names: echo ${(ko)options}
            for o in promptpercent promptbang promptsubst
            do
                if [[ "${options[$o]}" = on ]]; then
                    _LP_OLD_SETOPT+=("$o")
                else
                    _LP_OLD_SETOPT+=("no$o")
                fi
            done
        fi
    fi
    if (( _LP_SHELL_bash )); then
        # Prevent some cases where the user shoots in his own foot.
        # PROMPT_COMMAND is not exported by default, but some users
        # incorrectly export it from their profile/bashrc (GitHub #450),
        # so we preventively UNexport it.
        # TODO: warn the user if it was exported
        if (( ${BASH_VERSINFO[0]:-0} > 4 || ( ${BASH_VERSINFO[0]:-0} == 4 && ${BASH_VERSINFO[1]:-0} >= 2 ) )); then
            # -g is only available since bash 4.2
            declare -g +x PROMPT_COMMAND
        fi

        # Disable parameter/command expansion from PS1
        shopt -u promptvars
        PROMPT_COMMAND=__lp_set_prompt
    else # zsh
        # Set options that affect PS1 evaluation
        # Disable parameter/command expansion; enable percent expansion
        setopt promptpercent nopromptbang nopromptsubst
        add-zsh-hook precmd __lp_set_prompt
    fi
}

# Come back to the old prompt
prompt_off() {
    PS1=$LP_OLD_PS1
    if (( _LP_SHELL_bash )); then
        eval "$_LP_OLD_SHOPT"
        PROMPT_COMMAND="$LP_OLD_PROMPT_COMMAND"
    else # zsh
        add-zsh-hook -d precmd __lp_set_prompt
        setopt "${_LP_OLD_SETOPT[@]}"
        (( ${#_LP_ZSH_PROMPT_THEME} )) && prompt "$_LP_ZSH_PROMPT_THEME"
    fi
}

# Use an empty prompt: just the ❯ mark
prompt_OFF() {
    PS1="❯ "
    if (( _LP_SHELL_bash )); then
        shopt -u promptvars
        PROMPT_COMMAND="$LP_OLD_PROMPT_COMMAND"
    else # zsh
        add-zsh-hook -d precmd __lp_set_prompt
        setopt promptpercent nopromptbang nopromptsubst
    fi
}

lp_theme() {
    local theme=${1-}

    if [[ $theme == '--list' ]]; then
        local -a lp_theme_list
        __lp_theme_list
        printf '%s\n' "${lp_theme_list[@]}"
        return
    fi

    local f_prompt="_lp_${theme}_theme_prompt" f_dir="_lp_${theme}_theme_directory" f_activate="_lp_${theme}_theme_activate"

    if [[ -z $theme ]]; then
        printf '%s\n%s\n' \
            'Must pass in the name of a theme. If you meant the default Liquidprompt theme, try "default".' \
            'Run "lp_theme --list" to see all loaded and available themes.' 2>&1
        return 1
    fi

    if ! __lp_is_function "$f_prompt"; then
        printf 'Loading theme "%s" failed: cannot find function "%s". Please source the theme file first.\n' \
            "$theme" "$f_prompt" 2>&1
        return 2
    fi
    if ! __lp_is_function "$f_dir"; then
        f_dir=":"
    fi
    if ! __lp_is_function "$f_activate"; then
        f_activate=":"
    fi

    _LP_THEME_ACTIVATE_FUNCTION=$f_activate
    _LP_THEME_DIRECTORY_FUNCTION=$f_dir
    _LP_THEME_PROMPT_FUNCTION=$f_prompt

    "$f_activate"
    prompt_on
}

# By default, sourcing liquidprompt will activate Liquid Prompt
lp_activate

# vim: set et sts=4 sw=4 tw=120 ft=sh:
